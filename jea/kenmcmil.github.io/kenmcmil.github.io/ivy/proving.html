<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>IVy as a theorem prover</title>
  <meta name="description" content="
IVy is a research tool intended to allow interactive development of protocols and their proofs of correctness and to provide a platform for developing and experimenting with automated proof techniques. In particular, IVy provides interactive visualization of automated proofs, and supports a use model in which the human protocol designer and the automated tool interact to expose errors and prove correctness.
">

  <link rel="stylesheet" href="css/main.css">
  <link rel="canonical" href="https://microsoft.github.io/ivyhttps://kenmcmil.github.io/ivy/proving.html">
  <link rel="alternate" type="application/rss+xml" title="IVy" href="https://microsoft.github.io/ivyhttps://kenmcmil.github.io/ivy/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://kenmcmil.github.io/">IVy</a>

    <nav class="site-nav">
      <a href="proving.html#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
          <a class="page-link" href="credits.html">Credits</a>
          
        
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="index.html">Home</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
          <div class="grid">
    
    <div class="unit three-fourths">


      <article class="post">

	<header class="post-header">
	  <h1 class="post-title">IVy as a theorem prover</h1>
	</header>

	<div class="post-content">
	  <p>In the development of systems, we sometimes have to reason about
mathematical functions and relations in ways that automated theorem
provers can’t handle reliably. For these cases, IVy provides a
facility that allows the user to supply the necessary proofs. IVy’s
approach to theorem proving is designed to make maximal use of
automated provers. We do this by localizing the proof into
“isolates”. Our verification conditions in each isolate are confined
to a logical fragment or theory that an automated prover can handle
reliably.</p>

<h2 id="primitive-judgments">Primitive judgments</h2>

<p>A logical development in IVy is a succession of statements or
<em>judgments</em>. Each judgment must be justified by a primitive axiom or
inference rule.</p>

<h1 id="type-declarations">Type declarations</h1>

<p>On such primitive is a type declaration, like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    type t

</code></pre></div></div>
<p>This judgment can be read as “let <code class="language-plaintext highlighter-rouge">t</code> be a type”. It is admissible
provided <code class="language-plaintext highlighter-rouge">t</code> is new symbol that has not been used up to this point
in the development.</p>

<h1 id="functions-and-individuals">Functions and individuals</h1>

<p>We can introduce a constant like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    individual n : t

</code></pre></div></div>
<p>where <code class="language-plaintext highlighter-rouge">n</code> is new. This judgment can be read as “let <code class="language-plaintext highlighter-rouge">n</code> be a term of type
<code class="language-plaintext highlighter-rouge">t</code>” and is admissible if symbol <code class="language-plaintext highlighter-rouge">n</code> has not been used up to this point
in the development.</p>

<p>Similarly, we can introduce new function and relation symbols:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    function f(X:t) : t
    relation r(X:t,Y:t)


</code></pre></div></div>
<p>The first judgment can be read as “for any term <em>X</em> of type <em>t</em>, let
<em>f</em>(<em>X</em>) be a term of type <em>t</em>”.  The second says “for any terms
<em>X,Y</em> of type <em>t</em>, let <em>r</em>(<em>X</em>,<em>Y</em>) be a proposition” (a term of
type <code class="language-plaintext highlighter-rouge">bool</code>).</p>

<h1 id="axioms">Axioms</h1>

<p>An <em>axiom</em> is a proposition whose truth is admitted by fiat. For
example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    axiom [symmety_r] r(X,Y) -&gt; r(Y,X)


</code></pre></div></div>
<p>The free variables <em>X</em>,<em>Y</em> in the formula are taken as universally
quantified. The text <code class="language-plaintext highlighter-rouge">symmetry_r</code> between brackets is a name for the
axiom and is optional. The axiom is simply admitted in the current
context without proof. Axioms are dangerous, since they can
introduce inconsistencies. You should use axioms only if you are
developing a foundational theory and you know what you are doing, or
to make a temporary assumption that will later be removed.</p>

<h1 id="properties">Properties</h1>

<p>A <em>property</em> is a proposition that can be admitted as true only if
it follows logically from judgments in the current context. For
example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    property [myprop] r(n,X) -&gt; r(X,n)


</code></pre></div></div>
<p>A property requires a proof (see below). If a proof is not supplied,
IVy applies its default proof tactic.  This calls the
automated prover Z3 to attempt to prove the property from the
previously admitted judgments in the current context.</p>

<p>The default tactic works by generating a <em>verification condition</em> to
be checked by Z3. This is a formula whose validity implies that the
property is true in the current context. In this case, the
verification condition is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #-   (forall X,Y. r(X,Y) -&gt; r(Y,X)) -&gt; (r(n,X) -&gt; r(X,n))

</code></pre></div></div>
<p>That is, it states that axiom <code class="language-plaintext highlighter-rouge">symmetry_r</code> implies property <code class="language-plaintext highlighter-rouge">myprop</code>. 
IVy checks that this formula is within a logical fragment that Z3 can
decide, then passes the formula to Z3. If Z3 finds that the formula is
valid, the property is admitted.</p>

<h1 id="definitions">Definitions</h1>

<p>A definition is a special form of axiom that cannot introduce an
inconsistency. As an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    function g(X:t) : t

    definition g(X) = f(X) + 1

</code></pre></div></div>
<p>This can be read as “for all <em>X</em>, let <em>g</em>(<em>X</em>) equal <em>f</em>(<em>X</em>) + 1”. The
definition is admissible if the symbol <em>g</em> is “fresh”, meaning it
does not occur in any existing properties or definitions in the
current context.  Further <em>g</em> must not occur on the right-hand side
of the equality (that is, a recursive definition is not admissible
without proof – see “Recursion” below).</p>

<h1 id="theory-instantiations">Theory instantiations</h1>

<p>IVy has built-in theories that can be instantiated with a specific type
as their carrier. For example, the theory of integer arithmetic is
called <code class="language-plaintext highlighter-rouge">int</code>. It has the signature <code class="language-plaintext highlighter-rouge">{+,-,*,/,&lt;}</code>, plus the integer
numerals, and provides the axioms of Peano arithmetic. To instantiate
the theory <code class="language-plaintext highlighter-rouge">int</code> using type <em>u</em> for the integers, we write:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    type u
    interpret u -&gt; int

</code></pre></div></div>
<p>This declaration requires that type <code class="language-plaintext highlighter-rouge">u</code> is not previously interpreted
and that the symbols <code class="language-plaintext highlighter-rouge">{+,-,*,/,&lt;}</code> in the signature of <code class="language-plaintext highlighter-rouge">int</code> are
fresh. Notice, though, that the symbols <code class="language-plaintext highlighter-rouge">{+,-,*,/,&lt;}</code> are
overloaded. This means that <code class="language-plaintext highlighter-rouge">+</code> over distinct types is considered to
be a distinct symbol.  Thus, we can we can instantiate the <code class="language-plaintext highlighter-rouge">int</code>
theory over different types (and also instantiate other theories that
have these symbols in their signature).</p>

<h2 id="schemata">Schemata</h2>

<p>A <em>schema</em> is a compound judgment that takes a collection of judgments
as input (the premises) and produces a judgment as output (the
conclusion). If the schema is valid, then we can provide any
type-correct values for the premises and the conclusion will follow.</p>

<p>Here is a simple example of a schema taken as an axiom:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    axiom [congruence] {
        type d
        type r
        function f(X:d) : r
        #--------------------------
        property X = Y -&gt; f(X) = f(Y)
    }

</code></pre></div></div>
<p>The schema is contained in curly brackets and gives a list of premises
following a conclusion. In this case, it says that, given types <em>d</em> and <em>r</em> and a function <em>f</em> from
<em>d</em> to <em>r</em> and any values <em>X</em>,<em>Y</em> of type <em>d</em>,  we can infer that <em>X</em>=<em>Y</em> implies
<em>f</em>(<em>X</em>) = <em>f</em>(<em>Y</em>). The dashes separating the premises from the conclusion are
just a comment. The conclusion is always the last judgment in the schema.
Also, notice the declaration of function <em>f</em> contains a variable <em>X</em>. The scope of this
variable is only the function declaration. It has no relation to the variable <em>X</em> in the conclusion.</p>

<p>The keyword <code class="language-plaintext highlighter-rouge">axiom</code> tells IVy that this schema should be taken as valid
without proof. However, as we will see, the default
tactic treats a schema differently from a simple proposition. That is,
a schema is never used by default, but instead must be explicitly
instantiated.  This allows is to express and use facts that, if they
occurred in a verification condition, would take us outside the
decidable fragment.</p>

<p>Any judgment that has been admitted in the current context can be
<em>applied</em> in a proof. When we apply a schema, we supply values for its
premises to infer its conclusion.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    property [prop_n] Z = n -&gt; Z + 1 = n + 1
    proof {
        apply congruence
    }

</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">proof</code> declaration tells IVy to apply the axiom schema <code class="language-plaintext highlighter-rouge">congruence</code> to prove the property. 
IVy tries to match the proof goal <code class="language-plaintext highlighter-rouge">prop_n</code> to the schema’s conclusion by picking particular
values for premises, that is, the types <em>d</em>,<em>r</em> and function <em>f</em>. It also chooses terms for the
the free variables <em>X</em>,<em>Y</em> occurring in the schema. In this case, it
discovers the following assignment:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #- d = t
    #- r = t
    #- X = Z
    #- Y = n
    #- f(N) = N + 1

</code></pre></div></div>
<p>After plugging in this assignment, the conclusion of the rule exactly matches
the property to be proved, so the property is admitted.</p>

<p>The problem of finding an assignment such as the one above is one of
“second order matching”.  It is a hard problem, and the answer is not
unique. In case IVy did not succeed in finding the above match, we
could also have written the proof more explicitly, like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    property [prop_n_2] Z = n -&gt; Z + 1 = n + 1
    proof {
        apply congruence with X=Z, Y=n, f(X) = X:t + 1
    }

</code></pre></div></div>
<p>Each of the above equations acts as a constraint on the
assignment. That is, it must convert <em>X</em> to
<em>Z</em>, <em>Y</em> to <em>n</em> and <em>f</em>(<em>X</em>) to <em>X</em> + 1. Notice that we had to
explicitly type <em>X</em> on the right-hand side of the last equation,
since its type couldn’t be inferred (and in fact it’s not the same
as the type of <em>X</em> on the left-hand side, which is <em>d</em>).</p>

<p>It’s also possible to write constraints that do not allow for any
assignment. In this case, Ivy complains that the provided match is
inconsistent.</p>

<h1 id="forward-proofs">Forward proofs</h1>

<p>In the normal way of writing proofs, we start from a set of premises,
then proceed to prove a sequence of facts (or lemmata), ending in a
conclusion. Each fact must be seen to follow from the preceding facts
by applying a valid schema.</p>

<p>For example, consider the following axiom schema:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    relation man(X:t)
    relation mortal(X:t)

    axiom [mortality_of_man] {
        property [prem] man(X)
        #---------------
        property mortal(X)
    }


</code></pre></div></div>
<p>The scope of free variables such as <em>X</em> occurring in properties is
the entire schema. Thus, this schema says that, for any term <em>X</em> of
type <code class="language-plaintext highlighter-rouge">t</code>, if we can prove that <code class="language-plaintext highlighter-rouge">man(X)</code> is true, we can prove that
<code class="language-plaintext highlighter-rouge">mortal(X)</code> is true.</p>

<p>We take as a given that Socrates is a man, and prove he is mortal:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    individual socrates : t

    axiom [soc_man] man(socrates)

    property mortal(socrates)
    proof {
        apply mortality_of_man with prem = soc_man
    }


</code></pre></div></div>
<p>The axiom <code class="language-plaintext highlighter-rouge">mortality_of_man</code>, requires us supply the premise
<code class="language-plaintext highlighter-rouge">man(socrates)</code>.  Fortunately, we have this fact as an axiom.
To justify the conclusion <code class="language-plaintext highlighter-rouge">mortal(socrates)</code> we tell Ivy to apply
axiom <code class="language-plaintext highlighter-rouge">mortality_of_man</code> with <code class="language-plaintext highlighter-rouge">soc_man</code> as its premise.</p>

<p>Ivy achieves this proof by <em>matching</em> the axiom <code class="language-plaintext highlighter-rouge">mortality_of_man</code>
against the provided premise and conclusion. In this process, it
discovers the substitution <code class="language-plaintext highlighter-rouge">X = socrates</code>. Applying this substitution to
the axiom yields the deduction we wish to make.  However, if we wanted
to be more explicit about the substitution, we could have written:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    property mortal(socrates)
    proof {
        apply mortality_of_man with prem = soc_man, X = socrates
    }


</code></pre></div></div>
<p>Theorems
========</p>

<p>Thus far, we have seen schemata used only as axioms. However, we can also
prove the validity of a schema as a <em>theorem</em>. For example, here is a theorem
expressing the transitivity of equality:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    theorem [trans] {
        type t
        property [left] X:t = Y
        property [right] Y:t = Z
        #--------------------------------
        property X:t = Z
    }


</code></pre></div></div>
<p>We don’t need to provide a proof for this Ivy’s default tactic using Z3 can handle it. 
The verification condition that Ivy generates is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #-   X = Y &amp; Y = Z -&gt; X = Z

</code></pre></div></div>
<p>Here is a theorem that lets us eliminate universal quantifiers:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    theorem [elimA] {
        type t
        function p(W:t) : bool
        property [prem] forall Y. p(Y)
        #--------------------------------
        property p(X)
    }

</code></pre></div></div>
<p>It says, for any predicate <em>p</em>, if <code class="language-plaintext highlighter-rouge">p(Y)</code> holds for all <em>Y</em>, then
<code class="language-plaintext highlighter-rouge">p(X)</code> holds for a particular <em>X</em>. Again, Z3 can
prove this easily. Now let’s derive a consequence of these facts. A
function <em>f</em> is <em>idempotent</em> if applying it twice gives the same
result as applying it once. This theorem says that, if <em>f</em> is
idempotent, then applying <em>f</em> three times is the same as applying it
once:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    theorem [idem2] {
        type t
        function f(X:t) : t
        property [idem] forall X. f(f(X)) = f(X)
        #--------------------------------
        property f(f(f(X))) = f(X)
    }

</code></pre></div></div>
<p>The default tactic can’t prove this because the premise contains a
function cycle with a universally quantified variable. Here’s the
error message it gives:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #- error: The verification condition is not in the fragment FAU.
    #-
    #- The following terms may generate an infinite sequence of instantiations:
    #-   proving.ivy: line 331: f(f(X_h))

</code></pre></div></div>
<p>This means we’ll need to apply some other tactic. Here is one possible proof:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    proof {
        property [lem1] f(f(f(X))) = f(f(X)) proof {apply elimA with prem=idem}
        property [lem2] f(f(X)) = f(X) proof {apply elimA with prem=idem}
        apply trans with left = lem1
    }

</code></pre></div></div>
<p>We think this theorem holds because <code class="language-plaintext highlighter-rouge">f(f(f(X)))</code> is equal to <code class="language-plaintext highlighter-rouge">f(f(X))</code>
(by idempotence of <em>f</em>) which in turn is equal to <code class="language-plaintext highlighter-rouge">f(X)</code> (again, by
idempotence of <em>f</em>). We then apply transitivity to infer <code class="language-plaintext highlighter-rouge">f(f(f(X))) = f(X)</code>.</p>

<p>To prove that <code class="language-plaintext highlighter-rouge">f(f(f(X))) = f(f(X))</code> from idempotence, we apply the
<code class="language-plaintext highlighter-rouge">elimA</code> theorem with <code class="language-plaintext highlighter-rouge">idem</code> as the premise. Let’s look in a little more detail at how this works.
The <code class="language-plaintext highlighter-rouge">elimA</code> theorem has a premise <code class="language-plaintext highlighter-rouge">forall X. p(X)</code>. Ivy matches has to find a substitution that
will match this formulas <code class="language-plaintext highlighter-rouge">idem</code>, the premise that we want to use, which is <code class="language-plaintext highlighter-rouge">forall X. f(f(X)) = f(X)</code>.
It discovers the following substitution:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #- t = t
    #- p(Y) = f(f(Y)) = f(Y)

</code></pre></div></div>
<p>Now Ivy tries to match the conclusion <code class="language-plaintext highlighter-rouge">p(X)</code> against the property <code class="language-plaintext highlighter-rouge">lem1</code> we are proving, which
is <code class="language-plaintext highlighter-rouge">f(f(f(X))) = f(f(X))</code>. It first plugs in the above substitution, so <code class="language-plaintext highlighter-rouge">p(X)</code> becomes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #- f(f(X)) = f(X)

</code></pre></div></div>
<p>Matching this with our goal <code class="language-plaintext highlighter-rouge">lem1</code>, it then gets this substitution:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #- X = f(X)

</code></pre></div></div>
<p>Plugging these substitutions into <code class="language-plaintext highlighter-rouge">elimA</code> as defined above, we obtain:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #- theorem [elimA] {
    #-     property [prem] forall Y. f(f(Y)) = f(Y)
    #-     #--------------------------------
    #-     property f(f(f(X))) = f(f(X))
    #- }

</code></pre></div></div>
<p>which is just the inference we want to make. This might give the impression that Ivy can
magically arrive at the instantiation of a lemma needed to produce a desired inference.
In general, however, this is a hard problem. If Ivy fails, we can still write out the
full substitution manually, like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #- property [lem1] f(f(f(X))) = f(f(X))
    #- proof {
    #-     apply elimA with t=t, p(Y) = f(f(Y)) = f(Y), X=f(X)
    #- }

</code></pre></div></div>
<p>The second step of our proof, deriving the fact <code class="language-plaintext highlighter-rouge">f(f(X) = f(X)</code> is a
similar application of <code class="language-plaintext highlighter-rouge">idem</code>.  The final step uses transitivity,
with our two lemmas as premises. In this case, we only have to
specify the the <code class="language-plaintext highlighter-rouge">left</code> premise of <code class="language-plaintext highlighter-rouge">trans</code> is <code class="language-plaintext highlighter-rouge">lem1</code>. This is enough
to infer the needed substitution.  There would be no harm, however,
in writing <code class="language-plaintext highlighter-rouge">right=lem2</code>.</p>

<h1 id="natural-deduction">Natural deduction</h1>

<p>The above proof is an example of reasoning in a style called 
<a href="https://en.wikipedia.org/wiki/Natural_deduction">natural deduction</a>.
In fact, <code class="language-plaintext highlighter-rouge">elimA</code> is a primitive inference rule in natural deduction. 
In the natural deduction style, a premise of a theorem is often itself a theorem.
For example, here is a rule of natural deduction that is used to prove an implication:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    theorem [introImp] {
        function p : bool
        function q : bool
        theorem [lem] {
            property [prem] p
            #----------------------
            property q
        }
        #----------------------
        property p -&gt; q
    }

</code></pre></div></div>
<p>This rule says that, for any predicates <em>p</em> and <em>q</em>, if we can prove <em>q</em> from <em>p</em>, then
we can prove <code class="language-plaintext highlighter-rouge">p -&gt; q</code>. The premise <code class="language-plaintext highlighter-rouge">lem</code> of this rule is itself a lemma, which we have to
supply in order to use the rule.</p>

<p>As an application of <code class="language-plaintext highlighter-rouge">introImp</code>, let’s try to prove the following theorem:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    relation p
    relation q

    property p &amp; (p-&gt;q) -&gt; q

</code></pre></div></div>
<p>To apply <code class="language-plaintext highlighter-rouge">introImp</code> to prove the implication <code class="language-plaintext highlighter-rouge">p &amp; (p-&gt;q) -&gt; q</code>, we first need a proof of <code class="language-plaintext highlighter-rouge">q</code>
from <code class="language-plaintext highlighter-rouge">p &amp; (p-&gt;q)</code>. So here’s the start of a proof:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    proof {
        theorem [lem1] {
            property [p1] p &amp; (p -&gt; q)
            property q
        } 
        apply introImp
    }

</code></pre></div></div>
<p>Notice we didn’t actually prove <code class="language-plaintext highlighter-rouge">lem1</code>. By leaving out the proof, we
effectively pass the problem of proving <code class="language-plaintext highlighter-rouge">lem1</code> on to Z3. With this
lemma, we can then apply <code class="language-plaintext highlighter-rouge">introImp</code> to give us our goal. We could also
have said <code class="language-plaintext highlighter-rouge">with lem=lem1</code>, but we didn’t have to because Ivy can
figure out the premise needed by <code class="language-plaintext highlighter-rouge">introImp</code> just by matching the
conclusions.</p>

<p>Now, if we don’t want to burden Z3 with the proof of <code class="language-plaintext highlighter-rouge">lem1</code>, we can
fill it in. We’ll use this rule for eliminating implications:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    theorem [elimImp] {
        function p : bool
        function q : bool
        property [prem1] p
        property [prem2] p -&gt; q
        #----------------------
        property q
    }

</code></pre></div></div>
<p>This rule says that, for any predicates <em>p</em> and <em>q</em>, if we can
prove <em>p</em> and we can prove <code class="language-plaintext highlighter-rouge">p -&gt; q</code>, then we can prove <code class="language-plaintext highlighter-rouge">q</code>.  You
might also recognize the <code class="language-plaintext highlighter-rouge">elimImp</code> rule as <em>modus ponens</em>.</p>

<p>Here’s a slightly more detailed proof of our theorem that includes a
proof of <code class="language-plaintext highlighter-rouge">lem1</code>::</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    property p &amp; (p-&gt;q) -&gt; q
    proof {
        theorem [lem1] {
            property [p1] p &amp; (p -&gt; q)
            property q
        } proof {
            property [p2] p
            property [p3] p -&gt; q 
            apply elimImp with prem1 = p1
        }
        apply introImp
    }

</code></pre></div></div>
<p>That is, from <code class="language-plaintext highlighter-rouge">p &amp; (p -&gt; q)</code> we can infer <code class="language-plaintext highlighter-rouge">p</code> and <code class="language-plaintext highlighter-rouge">p -&gt; q</code>.
Notice that when we applied <code class="language-plaintext highlighter-rouge">elimImp</code>, we again specified
only one premise, since this was enough to determine the
substitution for <code class="language-plaintext highlighter-rouge">p</code> in the rule.</p>

<p>If we want to add more detail to the proof, we can can go another
level deeper by adding proofs for <code class="language-plaintext highlighter-rouge">p2</code> and <code class="language-plaintext highlighter-rouge">p3</code>. We’ll use these two
additional rules for eliminating “and” operators:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    axiom [elimAndL] {
        function p : bool
        function q : bool
        property [prem] p &amp; q
        #----------------------
        property p
    }

    axiom [elimAndR] {
        function p : bool
        function q : bool
        property [prem] p &amp; q
        #----------------------
        property q
    }

</code></pre></div></div>
<p>Here is the more detailed proof using <code class="language-plaintext highlighter-rouge">elimAndL</code> and <code class="language-plaintext highlighter-rouge">elimAndR</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    property p &amp; (p-&gt;q) -&gt; q
    proof {
        theorem [lem1] {
            property [p1] p &amp; (p -&gt; q)
            property q
        } proof {
            property [p2] p proof {apply elimAndL with prem = p1}
            property [p3] p -&gt; q proof {apply elimAndR with prem = p1}
            apply elimImp with prem1 = p2
        }
        apply introImp
    }

</code></pre></div></div>
<p>Notice the hierarchical style of proofs in natural deduction. Each lemma is
proved by a sequence of sub-lemmas, until we reach the bottom level at which
the lemmas are proved by primitive rules.</p>

<p>The full set of inference rules of natural deduction (including
equality) can be found in the the Ivy standard header <code class="language-plaintext highlighter-rouge">deduction</code>.
Many tutorial resources may be found on the World-Wide Web on writing
natural deduction proofs.</p>

<h1 id="backward-proof">Backward proof</h1>

<p>An alternative way to construct a proof in Ivy is <em>backward chaining</em>.
While it is perhaps most natural to use proof rules to work forward
from premises to conclusions, it is equally possible to use the same
rules to work backward from conclusions to premises.  When applying a
rule, Ivy does not require that all premises of the rule be
immediately supplied.  An unsupplied premise becomes a <em>subgoal</em> which
we must prove later. In effect, the proof of the missing premise is
“pushed on the stack”.</p>

<p>As an example, let’s look at an alternative proof of the mortality
of Socrates:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    property mortal(socrates)
    proof {
        apply mortality_of_man
        apply soc_man
    }


</code></pre></div></div>
<p>When we apply <code class="language-plaintext highlighter-rouge">mortality_of_man</code> to prove <code class="language-plaintext highlighter-rouge">mortal(socrates)</code> we lack the
necessary premise <code class="language-plaintext highlighter-rouge">man(socrates)</code>. Ivy is undeterred by this. It simply
matches the conclusion <code class="language-plaintext highlighter-rouge">mortal(X)</code> to <code class="language-plaintext highlighter-rouge">mortal(socrates)</code>, instantiates
the axiom <code class="language-plaintext highlighter-rouge">mortality_of_man</code> and pushes the needed premise <code class="language-plaintext highlighter-rouge">man(socrates)</code>
on the goal stack. We then discharge this goal using <code class="language-plaintext highlighter-rouge">soc_man</code>, leaving the
goal stack empty. Each proof step is applied to the top goal on the stack. 
As you may have guessed, goals remaining on the stack at the end of the ‘proof’
are passed to Z3.</p>

<p>When chaining proof rules backward, it is helpful to be able to see
the intermediate subgoals, since we do not write them
explicitly. This can be done with the <code class="language-plaintext highlighter-rouge">showgoals</code> tactic, like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    property mortal(socrates)
    proof {
        apply mortality_of_man
        showgoals
        apply soc_man
    }

</code></pre></div></div>
<p>When checking the proof, the <code class="language-plaintext highlighter-rouge">showgoals</code> tactic has the effect of
printing the current list of proof goals, leaving the goals
unchanged.  A good way to develop a backward proof is to start with
just the tactic <code class="language-plaintext highlighter-rouge">showgoals</code>, and to add tactics before it. Running
the Ivy proof checker in an Emacs compilation buffer is a convenient
way to do this.</p>

<h2 id="more-examples-of-backward-proofs">More examples of backward proofs</h2>

<p>Here, once again, is our theorem about idempotence:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    theorem [idem3] {
       type t
       function f(X:t) : t
       property forall X. f(f(X)) = f(X)
       #--------------------------------
       property f(f(f(X))) = f(X)
    }

</code></pre></div></div>
<p>Here is one possible proof in the backward style:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    proof  {
        apply trans with Y = f(f(X))
        apply elimA with X = f(X)
        apply elimA with X = X
    }

</code></pre></div></div>
<p>In fact, it is the same proof that we wrote in the forward style, but
it is now both more succinct and more difficult to understand.</p>

<p>As another example, here is our proof of theorem <code class="language-plaintext highlighter-rouge">mp</code> written in the
backward style:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    property p &amp; (p-&gt;q) -&gt; q
    proof {
        apply introImp
        apply elimImp with p = p
        apply elimAndL with q = (p-&gt;q)
        apply elimAndR with p = p
    }

</code></pre></div></div>
<p>Again, it is much more succinct, but offers no intuition as to <em>why</em> the
theorem is true.</p>

<p>When is a backward proof appropriate? One use case is when we wish to
make a small transformation to a very complex formula before passing
the problem to Z3. In this situation, writing out the resulting formula
as an explicit lemma is probably a waste of effort, since the formula is
intended to be consumed by an automated tool rather than a human user.</p>

<h1 id="skolemization-and-instantiation">Skolemization and instantiation</h1>

<p>Quantifiers are the usual reason that a proof goal lies outside
Ivy’s decidable fragment. Usually, the fastest way to prove
something that is not in the decidable fragment is to eliminate the
quantifier that is causing the problem. This is possible with
natural deduction, but sometimes very inconvenient. A better alternative is to
use Skolemization and instantiation.</p>

<p>Here is the idempotence lemma done in this style:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    theorem [idem4] {
        type t
        function f(W:t) : t
        property [idem] forall Y. f(f(Y)) = f(Y)
        #--------------------------------
        property f(f(f(X))) = f(X)
    }
    proof {
        instantiate idem with Y = X
    }

</code></pre></div></div>
<p>Remember that when we tried to prove this before, Ivy complained the
the term <code class="language-plaintext highlighter-rouge">f((Y))</code> put us outside the decidable fragment. This is
because <code class="language-plaintext highlighter-rouge">Y</code> was universally quantified in the premise <code class="language-plaintext highlighter-rouge">idem</code>. In
this proof, however, we use the <code class="language-plaintext highlighter-rouge">instantiate</code> tactic to plug in the
value <code class="language-plaintext highlighter-rouge">X</code> for the universally quantified <code class="language-plaintext highlighter-rouge">Y</code> in <code class="language-plaintext highlighter-rouge">idem</code>. This is
called <em>quantifier instantiation</em> and gives us the following proof
goal:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #- theorem [idem4] {
    #-     type t
    #-     function f(W:t) : t
    #-     property [idem] f(f(X)) = f(X)
    #-     #--------------------------------
    #-     property f(f(f(X))) = f(X)
    #- }

</code></pre></div></div>
<p>Without the quantifier, Z3 has no problem handling this proof goal.</p>

<p>It turns out we can always handle purely first-order proof goals in
this way, provided we apply a further tactic called
<code class="language-plaintext highlighter-rouge">skolemize</code>. This tactic allows us to deal with alternations of quantifiers.</p>

<p>Here is an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    theorem [sk1] {
        type t
        individual a : t
        relation r(X:t,Y:t)
        property [prem] forall X. exists Y. r(X,Y)
        #---
        property exists Z. r(a,Z)
    }
    proof {
        tactic skolemize
        instantiate prem with X=a
        instantiate with Z = _Y(a)
    }

</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">skolemize</code> tactic replaces the existentially quantified <code class="language-plaintext highlighter-rouge">Y</code> in <code class="language-plaintext highlighter-rouge">prem</code>
by a fresh function <code class="language-plaintext highlighter-rouge">_Y(X)</code>. Here is the resulting proof goal:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #- theorem [sk1] {
    #-     function _Y(V0:t) : t
    #-     type t
    #-     individual a : t
    #-     relation r(V0:t,V1:t)
    #-     property [prem] forall X. r(X,_Y(X))
    #-     property exists Z. r(a,Z)
    #- }

</code></pre></div></div>
<p>When <code class="language-plaintext highlighter-rouge">skolemize</code> is done, the premises have only universal
quantifiers, and the conclusion has only existential quantifiers.
Now, we can finish the proof by instantiating the universal in
<code class="language-plaintext highlighter-rouge">prem</code> with <code class="language-plaintext highlighter-rouge">a</code>, giving <code class="language-plaintext highlighter-rouge">r(a,_Y(a))</code>, and then instantiating the
existentially quantified <code class="language-plaintext highlighter-rouge">Z</code> in the conclusion with <code class="language-plaintext highlighter-rouge">_Y(a)</code> , which
also gives <code class="language-plaintext highlighter-rouge">r(a,_Y(a))</code>. One way to describe the instantiation of
the conclusion is that we have provided the term <code class="language-plaintext highlighter-rouge">_Y(a)</code> as a
<em>witness</em> for the existential quantifier. Our final proof goal is
trivial:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #- theorem [sk1] {
    #-     function _Y(V0:t) : t
    #-     type t
    #-     individual a : t
    #-     relation r(V0:t,V1:t)
    #-     property [prem] r(a,_Y(a))
    #-     property r(a,_Y(a))
    #- }

</code></pre></div></div>
<p>All of this wasn’t really necessary, since the original theorem is
in the decidable fragment.  However, the approach of Skolemization
followed by selective instantiation of quantifiers can be a quick
way to reduce a proof problem to a decidable one. First, we try to
get Z3 to discharge the proof goal automatically. If Ivy complains
about a quantified variable, we eliminate that variable by
Skolemization and instantiation. If we guess the wrong instantiation,
Ivy will give us a counterexample.</p>

<h2 id="avoiding-name-clashes">Avoiding name clashes</h2>

<p>How does Skolemization work if there is more than one variable with
the same name? As an example, suppose we have this axiom:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    relation s(X:t,Y:t)
    axiom [prem] forall X. exists Y. s(X,Y)

</code></pre></div></div>
<p>We would like to prove this property:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    individual a : t
    individual b : t
    property [sk2] exists Z,W. s(a,Z) &amp; s(b,W)

</code></pre></div></div>
<p>To prove this, we would like to use the axiom twice, once for <code class="language-plaintext highlighter-rouge">X=a</code>
and once for <code class="language-plaintext highlighter-rouge">X=b</code>. So let’s create two instances of it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    proof {
        instantiate [p1] prem with X=a
        instantiate [p2] prem with X=b
        tactic skolemize
        showgoals
    }

</code></pre></div></div>
<p>Notice we gave the two instances distinct names, <code class="language-plaintext highlighter-rouge">p1</code> and
<code class="language-plaintext highlighter-rouge">p2</code>. After Skolemization, this is the proof goal we got:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #- theorem [prop1] {
    #-     individual _Y : t
    #-     individual _Y_a : t
    #-     property [p1] s(a,_Y)
    #-     property [p2] s(b,_Y_a)
    #-     property exists W,Z. s(a,Z) &amp; s(b,W)
    #- }

</code></pre></div></div>
<p>The Skolem symbol in <code class="language-plaintext highlighter-rouge">p2</code> was automatically given a fresh name
<code class="language-plaintext highlighter-rouge">_Y_a</code> so as not to clash with the symbol <code class="language-plaintext highlighter-rouge">_Y</code> used in <code class="language-plaintext highlighter-rouge">p1</code>. Now we
could witness the conclusion with <code class="language-plaintext highlighter-rouge">W=_Y</code> and <code class="language-plaintext highlighter-rouge">Z=_Y_a</code>. This is
fragile, though, because changes to the proof might result in a name
different from <code class="language-plaintext highlighter-rouge">_Y_a</code>. A better approach is to use <em>alpha renaming</em> to
the two quantifiers different variable names. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    property exists Z,W. s(a,Z) &amp; s(b,W)
    proof {
        instantiate [p1] prem&lt;Y1/Y&gt; with X=a
        instantiate [p2] prem&lt;Y2/Y&gt; with X=b
        tactic skolemize
        instantiate with Z=_Y1, W=_Y2
    }

</code></pre></div></div>
<p>By renaming the bound variables in our two copies of the axiom to
be <code class="language-plaintext highlighter-rouge">Y1</code> and <code class="language-plaintext highlighter-rouge">Y2</code>, we can make sure that the Skolem symbols have
predictable names. Again, there was no need to use manual
instantiation for this simple problem, but in more complex cases
with nested quantifiers, this approach can make it possible to let Z3
do most of the quantifier instantiation work by only instantiating
the quantifiers that the fragment checker complains about.</p>

<h1 id="recursion">Recursion</h1>

<p>Recursive definitions are permitted in IVy by instantiating a
<em>definitional schema</em>. As an example, consider the following axiom schema:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #- axiom [rec[u]] {
    #-     type q
    #-     function base(X:u) : q
    #-     function step(X:q,Y:u) : q
    #-     fresh function fun(X:u) : q
    #-     #---------------------------------------------------------
    #-     definition fun(X:u) = base(X) if X &lt;= 0 else step(fun(X-1),X)
    #- }

</code></pre></div></div>
<p>This axiom was provided as part of the integer theory when we
interpreted type <em>u</em> as <code class="language-plaintext highlighter-rouge">int</code>.  It gives a way to construct a fresh
function <code class="language-plaintext highlighter-rouge">fun</code> from two functions:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">base</code> gives the value of the function for inputs less than or equal to zero.</li>
  <li><code class="language-plaintext highlighter-rouge">step</code> gives the value for positive <em>X</em> in terms of <em>X</em> and the value for <em>X</em>-1</li>
</ul>

<p>A definition schema such as this requires that the defined function
symbol be fresh. With this schema, we can define a recursive function that
adds the non-negative numbers less than or equal to <em>X</em> like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    function sum(X:u) : u

    definition {
       sum(X:u) = 0 if X &lt;= 0 else (X + sum(X-1))
    }
    proof {
       apply rec[u]
    }

</code></pre></div></div>
<p>Notice that we wrote the definition in curly brackets. This causes Ivy to 
treat it as an axiom schema, as opposed to a simple axiom.
We did this because the definition has a universally quantified variable
<code class="language-plaintext highlighter-rouge">X</code> under arithmetic operators, which puts it outside the decidable
fragment. Because this definition is a schema, when we want to use it,
we’ll have to apply it explicitly,</p>

<p>In order to admit this definition, we applied the definition
schema <code class="language-plaintext highlighter-rouge">rec[u]</code>. Ivy infers the following substitution:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #-  q=t, base(X) = 0, step(X,Y) = Y + X, fun(X) = sum(X)

</code></pre></div></div>
<p>This allows the recursive definition to be admitted, providing that
<code class="language-plaintext highlighter-rouge">sum</code> is fresh in the current context (i.e., we have not previously referred to
<code class="language-plaintext highlighter-rouge">sum</code> except to declare its type).</p>

<h3 id="extended-matching">Extended matching</h3>

<p>Suppose we want to define a recursive function that takes an additional
parameter. For example, before summing, we want to divide all the
numbers by <em>N</em>. We can define such a function like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    function sumdiv(N:u,X:u) : u

    definition
        sumdiv(N,X) = 0 if X &lt;= 0 else (X/N + sumdiv(N,X-1))
    proof
       apply rec[u]

</code></pre></div></div>
<p>In matching the recursion schema <code class="language-plaintext highlighter-rouge">rec[u]</code>, IVy will extend the
function symbols in the premises of <code class="language-plaintext highlighter-rouge">rec[u]</code> with an extra parameter <em>N</em> so that
schema becomes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #- axiom [rec[u]] = {
    #-     type q
    #-     function base(N:u,X:u) : q
    #-     function step(N:u,X:q,Y:u) : q
    #-     fresh function fun(N:u,X:u) : q
    #-     #---------------------------------------------------------
    #-     definition fun(N:u,X:u) = base(N,X) if X &lt;= 0 else step(N,fun(N,X-1),X)
    #- }

</code></pre></div></div>
<p>The extended schema matches the definition, with the following assignment:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #- q=t, base(N,X)=0, step(N,X,Y)=Y/N+X, fun(N,X) = sum2(N,X)

</code></pre></div></div>
<p>This is somewhat as if the functions were “curried”, in which case the
free symbol <code class="language-plaintext highlighter-rouge">fun</code> would match the partially applied term <code class="language-plaintext highlighter-rouge">sumdiv N</code>.
Since Ivy’s logic doesn’t allow for partial application of functions,
extended matching provides an alternative. Notice that, 
to match the recursion schema, a function definition must be
recursive in its <em>last</em> parameter.</p>

<h1 id="induction">Induction</h1>

<p>The default tactic can’t generally prove properties by induction. For
that IVy needs manual help. To prove a property by induction, we define
an invariant and prove it by instantiating an induction schema. Here is
an example of such a schema, that works for the non-negative integers:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    axiom [ind[u]] {
        relation p(X:u)
        theorem [base] {
            individual x:u
            property x &lt;= 0 -&gt; p(x)
        }
        theorem [step] {
            individual x:u
            property p(x) -&gt; p(x+1)
        }
        #--------------------------
        property p(X)    
    }

</code></pre></div></div>
<p>Like the recursion schema <code class="language-plaintext highlighter-rouge">rec[u]</code>, the induction schema <code class="language-plaintext highlighter-rouge">ind[u]</code> is
part of the integer theory, and becomes available when we interpret
type <code class="language-plaintext highlighter-rouge">u</code> as <code class="language-plaintext highlighter-rouge">int</code>.</p>

<p>Suppose we want to prove that <code class="language-plaintext highlighter-rouge">sum(Y)</code> is always greater than or equal
to <em>Y</em>, that is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    property [sumprop] sum(Y) &gt;= Y

</code></pre></div></div>
<p>We can prove this by applying our induction schema. Here is a backward version of the proof:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    proof [sumprop] {
        apply ind[u] with X = Y
        proof [base] {
            instantiate sum with X = x
        }
        proof [step] {
            instantiate sum with X = x + 1
        }
    }

</code></pre></div></div>
<p>Applying <code class="language-plaintext highlighter-rouge">ind[u]</code> produces two sub-goals, a base case and an induction step:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #- theorem [base] {
    #-    individual x:u
    #-    property x &lt;= 0 -&gt; sum(x) &gt;= x
    #- }

    #- theorem [step] {
    #-     individual x:u
    #-     property [step] sum(x) &gt;= x -&gt; sum(x+1) &gt;= x + 1
    #- }

</code></pre></div></div>
<p>The default tactic can’t prove these goals because the definition of
<code class="language-plaintext highlighter-rouge">sum</code> is a schema that must explicitly instantiated. Fortunately, it
suffices to instantiate this schema just for the specific arguments
of <code class="language-plaintext highlighter-rouge">sum</code> in our subgoals. For the base case, we need to instantiate
the definition for <code class="language-plaintext highlighter-rouge">X</code>, while for the induction step, we need
<code class="language-plaintext highlighter-rouge">X+1</code>. The effect of the <code class="language-plaintext highlighter-rouge">instantiate</code> tactic is to add an instance of the definition of
<code class="language-plaintext highlighter-rouge">sum</code> to the proof context, so in particular, it will be used by the default tactic.
Notice that we referred to the definition of <code class="language-plaintext highlighter-rouge">sum</code> by the name
<code class="language-plaintext highlighter-rouge">sum</code>.  Alternatively, we can name the definition itself and refer
to it by this name.</p>

<p>After instantiating the definition of <code class="language-plaintext highlighter-rouge">sum</code>, our two subgoals look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #- theorem [prop5] {
    #-     property [def2] sum(Y + 1) = (0 if Y + 1 &lt;= 0 else Y + 1 + sum(Y + 1 - 1))
    #-     property sum(Y) &gt;= Y -&gt; sum(Y + 1) &gt;= Y + 1
    #- }


    #- theorem [prop4] {
    #-     property [def2] sum(Y) = (0 if Y &lt;= 0 else Y + sum(Y - 1))
    #-     property Y:u &lt;= 0 -&gt; sum(Y) &gt;= Y
    #- }


</code></pre></div></div>
<p>Because these goals are quantifier-free the default tactic can easily
handle them, so our proof is complete.</p>

<p>As an alternative, here is the slightly more verbose forward version of this proof:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    property [sumprop2] sum(Y) &gt;= Y

    proof [sumprop2] {
        theorem [base] {
            individual x:u
            property x &lt;= 0 -&gt; sum(x) &gt;= x
        } proof {
            instantiate sum with X = x
        }
        theorem [step] {
            individual x:u
            property sum(x) &gt;= x -&gt; sum(x+1) &gt;= x + 1
        } proof {
            instantiate sum with X = x + 1
        }
        apply ind[u]
    }

</code></pre></div></div>
<p>This version is more clear than the backward version in that the base
case and inductive step of the proof are stated explicitly. For a complex
inductive hypothesis, this style might get a bit verbose. To reduce
the amount of text we need to type, we can introduce a function definition
inside a proof, like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    theorem [foo] {property sum(X) &gt;= X}
    proof {
        function inv(X) = sum(X) &gt;= X
        property inv(X) proof {
            theorem [base] {
                individual x:u
                property x &lt;= 0 -&gt; inv(x)
            } proof {
                instantiate sum with X = x
            }
            theorem [step] {
                individual x:u
                property inv(x) -&gt; inv(x + 1)
            } proof {
                instantiate sum with X = x + 1
            }
            apply ind[u]
        }
    }


</code></pre></div></div>

<h1 id="naming">Naming</h1>

<p>If we can prove that something exists, we can give it a name.  For
example, suppose that we can prove that, for every <em>X</em>, there exists a
<em>Y</em> such that <code class="language-plaintext highlighter-rouge">succ(X,Y)</code>. Then there exists a function that, given an
<em>X</em>, produces such a <em>Y</em>. We can define such a function called <code class="language-plaintext highlighter-rouge">next</code>
in the following way:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    relation succ(X:t,Y:t)
    axiom exists Y. succ(X,Y)

    property exists Y. succ(X,Y) named next(X)

</code></pre></div></div>
<p>Provided we can prove the property, and that <code class="language-plaintext highlighter-rouge">next</code> is fresh, we can
infer that, for all <em>X</em>, <code class="language-plaintext highlighter-rouge">succ(X,next(X))</code> holds. Defining a function
in this way, (that is, as a Skolem function) can be quite useful in
constructing a proof.  However, since proofs in Ivy are not generally
constructive, we have no way to <em>compute</em> the function <code class="language-plaintext highlighter-rouge">next</code>, so we
can’t use it in extracted code.</p>

<h2 id="hierarchical-proof-development">Hierarchical proof development</h2>

<p>As the proof context gets larger, it becomes increasingly difficult
for the automated prover to handle all of the judgments we have
admitted. This is especially true as combining facts or theories may
take us outside the automated prover’s decidable fragment. For this
reason, we need some way to break the proof into manageable parts.
For this purpose, IVy provides a mechanism to structure the proof into
a collection of localized proofs called <em>isolates</em>.</p>

<h1 id="isolates">Isolates</h1>

<p>An isolate is a restricted proof context. An isolate can make parts of
its proof context available to other isolates and keep other parts
hidden. Moreover, isolates can contain isolates, allowing us to
structure a proof development hierarchically.</p>

<p>Suppose, for example, that we want to define a function <em>f</em>, but keep
the exact definition hidden, exposing only certain properties of the
function. We could write something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    isolate t_theory = {

        implementation {
            interpret t -&gt; int
            definition f(X) = X + 1
        }

        theorem [expanding] { 
            property f(X) &gt; X
        }
        property [transitivity] X:t &lt; Y &amp; Y &lt; Z -&gt; X &lt; Z        

    }

</code></pre></div></div>
<p>Any names declared within the isolate belong to its namespace. For
example, the names of the two properties above are
<code class="language-plaintext highlighter-rouge">t_theory.expanding</code> and <code class="language-plaintext highlighter-rouge">t_theory.transitivity</code>.</p>

<p>The isolate contains four declarations. The first, says the type <code class="language-plaintext highlighter-rouge">t</code>
is to be interpreted as the integers. This instantiates the theory
of the integers for type <code class="language-plaintext highlighter-rouge">t</code>, giving the usual meaning to operators
like <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">&lt;</code>. The second defines <em>f</em> to be the integer successor
function.  These two declarations are contained an <em>implementation</em>
section. This means that the default tactic will use them only within
the isolate and not outside.</p>

<p>The remaining two statements are properties about <em>t</em> and <em>f</em> to
be proved. These properties are proved using only the context of the
isolate, without any judgments admitted outside.</p>

<p>Now suppose we want to prove an extra property using <code class="language-plaintext highlighter-rouge">t_theory</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    isolate extra = {

        theorem [prop] {  
            property Y &lt; Z -&gt; Y &lt; f(Z)
        }
        proof {
            instantiate t_theory.expanding with X = Z
        }
    }
    with t_theory

</code></pre></div></div>
<p>The ‘with’ clause says that the properties in <code class="language-plaintext highlighter-rouge">t_theory</code> should be
used by the default tactic within the isolate. In this case, the <code class="language-plaintext highlighter-rouge">transitivity</code> 
property will be used by default. This pattern is particularly useful when
we have a collection of properties of an abstract datatype that we wish to
use widely without explicitly instantiating them.</p>

<p>Notice that the default tactic will not use the interpretation of <em>t</em> as the
integers and the definition of <em>f</em> as the successor function, since
these are in the implementation section of isolate <code class="language-plaintext highlighter-rouge">t_theory</code> and are therefore
hidden from other isolates. Similarly, theorem <code class="language-plaintext highlighter-rouge">expanding</code> is not used by default
because it is a schema. This is as intended, since including any of these facts would
put the verification condition outside the decidable fragment.</p>

<p>We used two typical techniques here to keep the verification
conditions decidable.  First, we hid the integer theory and the
definition of <em>f</em> inside an isolate, replacing them with some
abstract properties. Second, we eliminated a potential cycle in the
function graph by instantiating the quantifier implicit in theorem
<code class="language-plaintext highlighter-rouge">expanding</code>, resulting in a stratified proof goal.</p>

<h1 id="hierarchies-of-isolates">Hierarchies of isolates</h1>

<p>An isolate can in turn contain isolates. This allows us to structure a
proof hierarchically. For example, the above proof could have been
structured like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    isolate extra2 = {

        function f(X:t) : t

        isolate t_theory = {

            implementation {
                interpret t -&gt; int
                definition f(X) = X + 1
            }

            theorem [expanding] { 
                property f(X) &gt; X
            }
            property [transitivity] X:t &lt; Y &amp; Y &lt; Z -&gt; X &lt; Z        

        }

        theorem [prop] {  
            property Y &lt; Z -&gt; Y &lt; f(Z)
        }
        proof
            assume t_theory.expanding with X = Z

    }

</code></pre></div></div>
<p>The parent isolate <code class="language-plaintext highlighter-rouge">extra2</code> uses only the visible parts of the child isolate <code class="language-plaintext highlighter-rouge">t_theory</code>.</p>

<h1 id="proof-ordering-and-refinement">Proof ordering and refinement</h1>

<p>Thus far, proof developments have been presented in order. That is,
judgments occur in the file in the order in which they are admitted
to the proof context.</p>

<p>In practice, this strict ordering can be inconvenient. For example,
from the point of view of clear presentation, it may often be better
to state a theorem, and <em>then</em> develop a sequence of auxiliary
definitions and lemmas needed to prove it.  Moreover, when developing
an isolate, we would like to first state the visible judgments, then
give the hidden implementation.</p>

<p>To achieve this, we can use a <em>specification</em> section. The
declarations in this section are admitted logically <em>after</em> the other
declarations in the isolate.</p>

<p>As an example, we can rewrite the above proof development so that the
visible properties of the isolates occur textually at the beginning:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    isolate extra3 = {

        function f(X:t) : t

        specification {
            theorem [prop] {  
                property Y &lt; Z -&gt; Y &lt; f(Z)
            }
            proof
                assume t_theory.expanding with X = Z
        }

        isolate t_theory = {

            specification {
                theorem [expanding] { 
                    property f(X) &gt; X
                }
                property [transitivity] X:t &lt; Y &amp; Y &lt; Z -&gt; X &lt; Z        
            }

            implementation {
                interpret t -&gt; int
                definition f(X) = X + 1
            }
        }
    }
</code></pre></div></div>

	</div>
	
      </article>

    </div>

    <div class="unit one-fourth hide-on-mobiles">
  <aside>
    
    <h4>Documentation</h4>
    <ul>

  
  
  <li class=""><a href="install.html">Installing IVy</a></li>

  
  
  <li class=""><a href="language.html">The Ivy language</a></li>

  
  
  <li class=""><a href="commands.html">IVy command reference</a></li>

  
  
  <li class=""><a href="decidability.html">Decidability</a></li>

  
  
  <li class="current"><a href="proving.html">IVy as a theorem prover</a></li>

</ul>

    
    <h4>IVy by example</h4>
    <ul>

  
  
  <li class=""><a href="examples/client_server_example.html">Invariants</a></li>

  
  
  <li class=""><a href="examples/specification.html">Specifications</a></li>

  
  
  <li class=""><a href="examples/datatypes.html">Abstract Datatypes</a></li>

  
  
  <li class=""><a href="examples/leader.html">Parameterized systems</a></li>

  
  
  <li class=""><a href="examples/helloworld.html">Hello, world!</a></li>

  
  
  <li class=""><a href="examples/networking.html">Networking</a></li>

  
  
  <li class=""><a href="examples/values.html">Concrete data</a></li>

  
  
  <li class=""><a href="examples/list_reverse.html">Deduction example: array reversal</a></li>

  
  
  <li class=""><a href="examples/indexset.html">Deduction example: majority</a></li>

  
  
  <li class=""><a href="examples/window.html">Example: sliding window</a></li>

  
  
  <li class=""><a href="examples/number_theory.html">Number theory</a></li>

</ul>

    
    <h4>Sharded Hash Table</h4>
    <ul>

  
  
  <li class=""><a href="examples/sht/sharded_hash_table.html">Introduction</a></li>

  
  
  <li class=""><a href="examples/sht/key.html">Keys</a></li>

  
  
  <li class=""><a href="examples/sht/shard.html">Shards</a></li>

  
  
  <li class=""><a href="examples/sht/table.html">Tables</a></li>

  
  
  <li class=""><a href="examples/sht/delmap.html">Delegation Map</a></li>

  
  
  <li class=""><a href="examples/sht/seqnum.html">Sequence Numbers</a></li>

  
  
  <li class=""><a href="examples/sht/queue.html">Message Queues</a></li>

  
  
  <li class=""><a href="examples/sht/trans.html">Transport Service</a></li>

  
  
  <li class=""><a href="examples/sht/reference.html">Reference object</a></li>

  
  
  <li class=""><a href="examples/sht/proto.html">Protocol</a></li>

  
  
  <li class=""><a href="examples/sht/sht.html">Final Assembly</a></li>

</ul>

    
    <h4>Compositional Testing</h4>
    <ul>

  
  
  <li class=""><a href="examples/testing/intro.html">Introduction</a></li>

  
  
  <li class=""><a href="examples/testing/specification.html">Specifications</a></li>

  
  
  <li class=""><a href="examples/testing/leader.html">Layered protocols</a></li>

</ul>

    
  </aside>
</div>


    <div class="clear"></div>

  </div>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>IVy</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>
IVy is a research tool intended to allow interactive development of protocols and their proofs of correctness and to provide a platform for developing and experimenting with automated proof techniques. In particular, IVy provides interactive visualization of automated proofs, and supports a use model in which the human protocol designer and the automated tool interact to expose errors and prove correctness.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
