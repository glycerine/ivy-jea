<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Specifications</title>
  <meta name="description" content="
IVy is a research tool intended to allow interactive development of protocols and their proofs of correctness and to provide a platform for developing and experimenting with automated proof techniques. In particular, IVy provides interactive visualization of automated proofs, and supports a use model in which the human protocol designer and the automated tool interact to expose errors and prove correctness.
">

  <link rel="stylesheet" href="../../css/main.css">
  <link rel="canonical" href="https://microsoft.github.io/ivyhttps://kenmcmil.github.io/ivy/examples/testing/specification.html">
  <link rel="alternate" type="application/rss+xml" title="IVy" href="https://microsoft.github.io/ivyhttps://kenmcmil.github.io/ivy/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://kenmcmil.github.io/">IVy</a>

    <nav class="site-nav">
      <a href="specification.html#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
          <a class="page-link" href="../../credits.html">Credits</a>
          
        
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="../../index.html">Home</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
          <div class="grid">
    
    <div class="unit three-fourths">


      <article class="post">

	<header class="post-header">
	  <h1 class="post-title">Specifications</h1>
	</header>

	<div class="post-content">
	  <p>Formal verification is primarily about establishing relationships
between specifications at differing levels of abstraction. The same
can be said of compositional testing. The difference is that in the
compositional testing approach, we combine formal proof with
specification-based testing to increase our confidence in the
correctness of a system.</p>

<p>Consider, for example, a network protocol, such as the <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP
protocol</a>
that is widely used to communicate streams of data over the Internet.
At a high level of abstraction, TCP is a <em>service</em>, providing methods
for establishing connections, and sending or receiving data. This
service provides guarantees to its users of reliable in-order
transmission of streams of bytes. At a lower level of abstraction, TCP
can be seen as a <em>protocol</em>. The protocol is a set of rules (laid out
in <a href="https://tools.ietf.org/html/rfc675">RFC 675</a> and later documents)
that implements service guarantees of TCP by exchanging datagrams over
an unreliable network.</p>

<p>The service and protocol specifications of TCP are views of the same
process observed at different interfaces. That is, TCP is sandwiched
between a higher-level application (say, a web browser and web server)
and the lower-level datagram protocol (typically the IP protocol) as shown below:</p>

<p><img src="../../images/network_stack1.png" alt="Network Stack" /></p>

<p>The TCP service specification describes the events we observe at the
interface between the application layer and the transport layer.  The
IP service specification describes the events we observe at the
interface between the transport layer and the network layer.  The TCP
protocol specification describes the <em>relation</em> between events at this
interface and the lower-level interface between transport and network
layers.</p>

<p>If we were developing the TCP protocol specification, we would like to
verify that the IP service and the TCP protocol together implement the
TCP service specification. That is, if events at the transport/network
interface are consistent with the IP service specification, and if we
execute the TCP protocol according to its specification, then events
at the application/transport interface should be consistent with the TCP
service specification. From the point of view of the TCP protocol, we
say that the IP service specification is an <em>assumption</em>, while the
TCP service specification is a <em>guarantee</em>.</p>

<p>IVy has features that allow us to combine testing with formal
verification to perform this kind of reasoning. It allows us to:</p>

<ul>
  <li>Define objects with interfaces</li>
  <li>Write specifications about interfaces</li>
  <li>Test assume/guarantee relationships between these specifications</li>
</ul>

<p>In IVy, interfaces and specifications are objects. An interface is
an object with unimplemented actions (a bit like an instance of an
abstract class in C++). A specification is a special object that
monitors the calls and returns across an interface and makes assertions
about their correctness.</p>

<h3 id="monitors-as-specifications">Monitors as specifications</h3>

<p>To specify services such as TCP, we need to make assertions about the
<em>sequences</em> of events that can occur at an interface. For example, in
TCP, we need to make statements relating the sequences of send and
receive events to abstract data streams that are transmitted between
clients. Specifications about sequences of events in time are often
referred to as <em>temporal</em> specifications.</p>

<p>A common approach to temporal specification is to define a specialized
logical notation called a <a href="http://plato.stanford.edu/entries/logic-temporal"><em>temporal
logic</em></a>. These
notations make it possible to write succinct temporal specifications,
and also us to do some proofs in a fully automated way using <a href="http://www.loria.fr/~merz/papers/mc-tutorial.pdf">model
checking</a>.</p>

<p>IVy takes a different approach.  Temporal specifications in IVy are
defined using special objects called <em>monitors</em>. A monitor is an
object that synchronizes its actions with calls and returns across an
interface. This allows the monitor to record information about the
history of the interface in its local state, and to assert facts that
should be true about interface events based on the history of previous
events.</p>

<p>As an example, here is a definition of an interface for a ridiculously
simple network service:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#lang ivy1.6
type packet

object intf = {
    action send(x:packet)
    action recv(x:packet)
}
</code></pre></div></div>

<p>The type <code class="language-plaintext highlighter-rouge">packet</code> is an example of an <a href="../../language.html#declarations"><em>uninterpreted type</em></a>. We don’t
yet know want the contents of a packet are, but we can fill in the
definition of <code class="language-plaintext highlighter-rouge">packet</code> later.</p>

<p>The actions in an interface object don’t have definitions. These will
be filled in by other objects that implement the different roles in
the interface. We don’t know yet what these objects actually do, but
we can write a service specification that tells us something about the
temporal behavior at the interface:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object spec = {
    relation sent(X:packet)

    after init {
        sent(X) := false
    }

    before intf.send {
        sent(x) := true
    }

    before intf.recv {
        assert sent(x)
    }
}
</code></pre></div></div>

<p>Object <code class="language-plaintext highlighter-rouge">spec</code> is a monitor. It has one local state component <code class="language-plaintext highlighter-rouge">sent</code>
that records the set of packets that have been sent so far.  The
<code class="language-plaintext highlighter-rouge">after init</code> declaration says that, initially, no packet <code class="language-plaintext highlighter-rouge">X</code> has been sent.
In <a href="../../language.html">the Ivy language</a>, symbols beginning with
capital letters are logical variables. Unbound variables are
implicitly universally quantified.</p>

<p>Information about sent packets is recorded by inserting an action
<em>before</em> every call to <code class="language-plaintext highlighter-rouge">intf.send</code>. This is done using a <code class="language-plaintext highlighter-rouge">before</code>
declaration in the specification. Notice that the inserted action can
refer to the parameters of <code class="language-plaintext highlighter-rouge">intf.send</code> and it can update the monitor
state.  In addition, the monitor inserts an assertion before every
call to <code class="language-plaintext highlighter-rouge">intf.recv</code>. This assertion states that the received packet
<code class="language-plaintext highlighter-rouge">x</code> has previously been sent.</p>

<p>In effect, our service specification describes a channel that can
re-order and duplicate packets, but cannot corrupt packets. If any
corrupted packet is received, the assertion will fail.</p>

<p>Now let’s consider some possible implementations of this very simple
specification. Here is the most trivial one:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object protocol = {
    implement intf.send {
        call intf.recv(x)
    }
}
</code></pre></div></div>

<p>Object <code class="language-plaintext highlighter-rouge">protocol</code> provides the implementation of action <code class="language-plaintext highlighter-rouge">intf.send</code>
using an <code class="language-plaintext highlighter-rouge">implement</code> declaration. This declaration provides the
missing body of the action <code class="language-plaintext highlighter-rouge">intf.send</code>. The implementation simply calls <code class="language-plaintext highlighter-rouge">intf.recv</code>
on the sent packet <code class="language-plaintext highlighter-rouge">x</code>. The assertion in monitor <code class="language-plaintext highlighter-rouge">spec</code> is always
true, since before calling <code class="language-plaintext highlighter-rouge">intf.send</code>, the packet <code class="language-plaintext highlighter-rouge">x</code> is added to the
relation <code class="language-plaintext highlighter-rouge">sent</code>. That is, our implementation trivially satisfies the
specification “receive only sent packets”.</p>

<p>To verify our implementation, we need to put it in a suitable
environment. The following statements tell us that the environment
will implement <code class="language-plaintext highlighter-rouge">intf.recv</code> and will call <code class="language-plaintext highlighter-rouge">intf.send</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import intf.recv
export intf.send
</code></pre></div></div>

<p>In order to test our program, we need to give a concrete interpretation to
the abstract type <code class="language-plaintext highlighter-rouge">packet</code>. It doesn’t much matter what this interpretation is.
This statement tells IVy to represent packets using 16-bit binary numbers:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interpret packet -&gt; bv[16]
</code></pre></div></div>

<p>Now, let’s do some verification. The IVy compiler can translate our
program into C++, and also generate a randomized tester that takes the
role of the environment. We save the above text to the file
<code class="language-plaintext highlighter-rouge">trivnet.ivy</code>, then compile like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ivy_to_cpp target=test build=true trivnet.ivy
g++ -I $Z3DIR/include -L $Z3DIR/lib -g -o trivnet trivnet.cpp -lz3
</code></pre></div></div>

<p>The command line options tell <code class="language-plaintext highlighter-rouge">ivy_to_cpp</code> to generate a test environment
and to use the C++ compiler to generate an executable file. When we run the
executable, the output looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./trivnet
&gt; intf.send(61468)
&lt; intf.recv(61468)
&gt; intf.send(49878)
&lt; intf.recv(49878)
&gt; intf.send(18736)
&lt; intf.recv(18736)
&gt; intf.send(41051)
&lt; intf.recv(41051)
...
</code></pre></div></div>

<p>The output lines beginning with <code class="language-plaintext highlighter-rouge">&gt;</code> represent calls from the test
environment into the system, while lines beginning with <code class="language-plaintext highlighter-rouge">&lt;</code> are calls
from the system into the environment. The specification monitor is
checking that every call to <code class="language-plaintext highlighter-rouge">intf.recv</code> corresponds to some previous
call to <code class="language-plaintext highlighter-rouge">intf.send</code>. This input values are just random 16-bit
numbers. Since our implementation is correct, no errors are flagged.</p>

<p>To get a better idea of what is happening with <code class="language-plaintext highlighter-rouge">before</code> and
<code class="language-plaintext highlighter-rouge">implements</code>, we can print out the program that results from inserting
the monitor actions and interface implementations. Here is part of the output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ivy_show trivnet.ivy

type packet
relation spec.sent(V0:packet)

after init {
    spec.sent(X) := false
}
action intf.recv(x:packet) = {
    assert spec.sent(x)
}
action intf.send(x:packet) = {
    spec.sent(x) := true;
    call intf.recv(x)
}
</code></pre></div></div>

<p>Notice that the <code class="language-plaintext highlighter-rouge">before</code> actions of <code class="language-plaintext highlighter-rouge">spec</code> have been inserted at the
beginning of these actions, and the <code class="language-plaintext highlighter-rouge">implement</code> action of <code class="language-plaintext highlighter-rouge">protocol</code>
has been used as the body of <code class="language-plaintext highlighter-rouge">intf.send</code>.</p>

<p>Of course, we might consider a (slightly) less trivial implementation,
such as this one that implements the service specification with a
one-place buffer:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object protocol = {
    individual full : bool
    individual contents : packet
    after init {
        full := false
    }

    implement intf.send {
        full := true;
        contents := x
    }

    action async = {
        if full {
            full := false;
            call intf.recv(contents)
        }
    }
}
</code></pre></div></div>

<p>This implementation has an action <code class="language-plaintext highlighter-rouge">async</code> that needs to be called by the
environment, so we add:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export protocol.async
</code></pre></div></div>

<p>The output from the tester looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./trivnet2
&gt; intf.send(59132)
&gt; intf.send(18535)
&gt; protocol.async()
&lt; intf.recv(18535)
&gt; intf.send(11708)
&gt; intf.send(15030)
&gt; protocol.async()
&lt; intf.recv(15030)
&gt; intf.send(64574)
&gt; intf.send(23863)
&gt; intf.send(63393)
&gt; protocol.async()
&lt; intf.recv(63393)
</code></pre></div></div>

<p>The tester is calling <code class="language-plaintext highlighter-rouge">intf.send</code> and <code class="language-plaintext highlighter-rouge">protocol.async</code> uniformly at
random (with a probability of 0.5 for each). We can see that some
packets (for example the first) are dropped.</p>

<p>Let’s put a bug in the protocol to see what happens. The action
<code class="language-plaintext highlighter-rouge">bug</code> below corrupts the packet buffer:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    action bug(p:packet) = {
        contents := p
    }

...
 
export protocol.bug
</code></pre></div></div>

<p>Here’s a test run:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./trivnet3
&gt; protocol.async()
&gt; protocol.async()
&gt; intf.send(18535)
&gt; protocol.bug(61184)
&gt; intf.send(31188)
&gt; intf.send(18749)
&gt; protocol.async()
&lt; intf.recv(18749)
&gt; protocol.bug(6178)
&gt; intf.send(28724)
&gt; protocol.bug(45283)
&gt; protocol.bug(6070)
&gt; protocol.bug(2590)
&gt; protocol.bug(10158)
&gt; protocol.async()
trivnet3.ivy: line 22: : assertion failed
</code></pre></div></div>

<p>At some point, the environment calls <code class="language-plaintext highlighter-rouge">bug</code> then <code class="language-plaintext highlighter-rouge">async</code> causing the
protocol to deliver a wrong packet value. We can see that the
specification monitor is in fact running, and it gives an error
message pointing to the line in the code where an assertion failed.</p>

<h3 id="assume-guarantee-reasoning-in-ivy">Assume-Guarantee reasoning in IVy</h3>

<p>In the previous example, we saw that a service specification is a kind
of abstraction. It hides details of the underlying implementation,
telling us only what we need to know to use the service. Abstractions
are crucial in reasoning about complex systems. They allow us to
develop one component of a system without thinking about the details
of the implementation of other components. For example, when
developing a network application based on TCP, we don’t have to read
RFC 675. We just rely on the simple service guarantee that TCP
provides (reliable, in-order delivery). The service specification
allows us to think about our application in <em>isolation</em> from the
network protocol stack.</p>

<p>IVy provides a mechanism to do just this when proving correctness of
system components. That is, we can isolate a single object in our
system and prove its correctness using only the service specifications
of its interfaces.</p>

<p>As an example, let’s build a system of two components that plays a
highly simplified game of ping-pong. Here is the interface definition:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#lang ivy1.6

object intf = {
    action ping
    action pong
}
</code></pre></div></div>

<p>Here is the interface specification:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type side_t = {left,right}

object spec = {
    individual side : side_t
    after init {
        side := left
    }

    before intf.ping {
        assert side = left;
        side := right
    }

    before intf.pong {
        assert side = right;
        side := left
    }
}
</code></pre></div></div>

<p>The specification has a single state component <code class="language-plaintext highlighter-rouge">side</code> that keeps track
of whether the ball is on the left- or right-hand side of the
table. When the ball is on the left, a <code class="language-plaintext highlighter-rouge">ping</code> action is allowed,
sending the ball to the right-hand side.  When the ball is on the
right, a <code class="language-plaintext highlighter-rouge">pong</code> is allowed, sending the ball to the left again.  A
failure to alternate <code class="language-plaintext highlighter-rouge">ping</code> and <code class="language-plaintext highlighter-rouge">pong</code> would cause one of the
assertions to fail.</p>

<p>Now let’s implement the left-hand player:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object left_player = {
    individual ball : bool
    after init {
        ball := true
    }

    action hit = {
        if ball {
            call intf.ping;
            ball := false
        }
    }

    implement intf.pong {
        ball := true
    }

}
</code></pre></div></div>

<p>The player has a Boolean <code class="language-plaintext highlighter-rouge">ball</code> that indicates the ball is in the
player’s court. We assume the left player serves, so <code class="language-plaintext highlighter-rouge">ball</code> is
initially true. If the left player has the ball, the <code class="language-plaintext highlighter-rouge">hit</code> action
will call <code class="language-plaintext highlighter-rouge">ping</code>, sending the ball to the right, and set <code class="language-plaintext highlighter-rouge">ball</code> to false.  The
left player implements <code class="language-plaintext highlighter-rouge">ping</code> by setting <code class="language-plaintext highlighter-rouge">ball</code> to true.</p>

<p>The right-hand player is similar:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object right_player = {
    individual ball : bool
    after init {
        ball := false
    }

    action hit = {
        if ball {
            call intf.pong;
            ball := false
        }
    }

    implement intf.ping {
        ball := true
    }

}
</code></pre></div></div>

<p>Let’s export the <code class="language-plaintext highlighter-rouge">hit</code> actions to the environment, so the players
will do something:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export left_player.hit
export right_player.hit
</code></pre></div></div>

<p>Here is the call graph of the system we have defined:</p>

<p><img src="pingpong_fig1-crop-1.png" alt="Ping Pong Call Graph" /></p>

<p>Now what we want to do is to generate testers for the left and right
players in isolation. That is, we want the tester for the left player
to act as its environment. This means the tester has to call both
<code class="language-plaintext highlighter-rouge">left_player.hit</code> and <code class="language-plaintext highlighter-rouge">intf.pong</code>. Similarly, the tester for the right
player has to call <code class="language-plaintext highlighter-rouge">right_player.hit</code> and <code class="language-plaintext highlighter-rouge">intf.ping</code>.</p>

<p>To generate these testers, we use <code class="language-plaintext highlighter-rouge">isolate</code> declarations:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>isolate iso_l = left_player with spec
isolate iso_r = right_player with spec
</code></pre></div></div>

<p>The first says to isolate the left player using the interface
specification <code class="language-plaintext highlighter-rouge">spec</code>.  The second says to do the same thing with the
right player. This reduces the system verification problem to two
separate verification problems called “isolates”.</p>

<p>Here’s the call graph for the left player isolate <code class="language-plaintext highlighter-rouge">iso_l</code>:</p>

<p><img src="pingpong_fig2-crop-1.png" alt="Ping Pong Call Graph 2" /></p>

<p>We can see what the first isolate looks like textually as follows (leaving a few
things out):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ivy_show isolate=iso_l pingpong.ivy

individual spec.side : side_t
relation left_player.ball

action ext:left_player.hit = {
    if left_player.ball {
        call intf.ping;
        left_player.ball := false
    }
}

action intf.ping = {
    assert spec.side = left;
    spec.side := right
}

action ext:intf.pong = {
    assume spec.side = right;
    spec.side := left;
    left_player.ball := true
}
</code></pre></div></div>

<p>Several interesting things have happened here. First, notice the
action <code class="language-plaintext highlighter-rouge">intf.ping</code>. We see that the code inserted by <code class="language-plaintext highlighter-rouge">spec</code> is
present, but the implementation provided by <code class="language-plaintext highlighter-rouge">right_player</code> is missing.
In effect, the right player has been abstracted away: we see neither
its state nor its actions.  Further, notice that the action <code class="language-plaintext highlighter-rouge">pong</code> has
been exported to the environment. It contains the monitor code from
<code class="language-plaintext highlighter-rouge">spec</code> and also the left player’s implementation of <code class="language-plaintext highlighter-rouge">pong</code>. There is a
crucial change, however: the <code class="language-plaintext highlighter-rouge">assert</code> in the specification of <code class="language-plaintext highlighter-rouge">pong</code>
has changed to <code class="language-plaintext highlighter-rouge">assume</code>.</p>

<p>This is an example of <em>assume-guarantee</em> reasoning. The left player
<em>guarantees</em> to call <code class="language-plaintext highlighter-rouge">ping</code> only when the ball is on the
left. However, it <em>assumes</em> that the right player only calls <code class="language-plaintext highlighter-rouge">pong</code>
when the ball is on the right. This is a very common situation in protocols. 
Each participant in the protocol guarantees correctness of its outputs,
but only so long as its inputs are correct.</p>

<p>Let’s start by testing the left player. First, we compile a tester:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ivy_to_cpp isolate=iso_l target=test build=true pingpong.ivy 
g++ -I $Z3DIR/include -L $Z3DIR/lib -g -o pingpong pingpong.cpp -lz3
</code></pre></div></div>

<p>Notice we specified the isolate <code class="language-plaintext highlighter-rouge">iso_l</code> on the command line.  Now
let’s run <code class="language-plaintext highlighter-rouge">pingpong</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./pingpong
&gt; left_player.hit()
&lt; intf.ping
&gt; left_player.hit()
&gt; intf.pong()
&gt; left_player.hit()
&lt; intf.ping
&gt; left_player.hit()
&gt; intf.pong()
&gt; left_player.hit()
&lt; intf.ping
...
</code></pre></div></div>

<p>We can see that the environment (the calls marked with <code class="language-plaintext highlighter-rouge">&gt;</code>) is
respecting the assumption of the left player that <code class="language-plaintext highlighter-rouge">pong</code> occurs only
when the ball is on the right, that is, after a <code class="language-plaintext highlighter-rouge">ping</code>. The tester is
sampling uniformly out of just the actions that satisfy the isolate’s
assumptions. You may notice that sometimes the environment calls <code class="language-plaintext highlighter-rouge">hit</code>
when the left player doesn’t have the ball. This is not a problem,
since a <code class="language-plaintext highlighter-rouge">hit</code> has no effect in this case. What if we neglected to test whether the left player in fact has the ball in the implementation?
Let’s try it. That is, let’s use this version of the left player’s <code class="language-plaintext highlighter-rouge">hit</code> action:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>action hit = {
    call intf.ping;
    ball := false
}
</code></pre></div></div>

<p>Here’s what we get:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./pingpong_bad
&gt; left_player.hit()
&lt; intf.ping
&gt; left_player.hit()
pingpong_bad.ivy: line 15: : assertion failed
</code></pre></div></div>

<p>The left player hits when it shouldn’t and causes a failure of the
precondition of <code class="language-plaintext highlighter-rouge">ping</code>.</p>

<p>Now let’s consider try right player. We compile and run a tester for
the isolate <code class="language-plaintext highlighter-rouge">iso_r</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ivy_to_cpp isolate=iso_r target=test build=true pingpong.ivy 
g++ -I $Z3DIR/include -L $Z3DIR/lib -g -o pingpong pingpong.cpp -lz3
$ ./pingpong
&gt; right_player.hit
&gt; right_player.hit
&gt; right_player.hit
&gt; intf.ping
&gt; right_player.hit
&lt; intf.pong
&gt; right_player.hit
&gt; intf.ping
&gt; right_player.hit
&lt; intf.pong
&gt; intf.ping
</code></pre></div></div>

<p>Here we see that the testing environment is generating calls to <code class="language-plaintext highlighter-rouge">ping</code>
and right_player.hit. The <code class="language-plaintext highlighter-rouge">ping</code> calls satisfy the precondition of
<code class="language-plaintext highlighter-rouge">ping</code>, that is, <code class="language-plaintext highlighter-rouge">ping</code> is only called when the ball is on the left
side. The specification monitor is checking that the <code class="language-plaintext highlighter-rouge">pong</code> calls
generated by the right player satisfy the precondition of <code class="language-plaintext highlighter-rouge">pong</code>.</p>

<p>So what have we done so far? We’ve verified by randomized testing the
the left player guarantees correct pings assuming correct pongs. We’ve
also verified by testing that the right player guarantees correct pongs
given correct pings. Since neither the pings nor the pongs can be the
first to fail, we can conclude that all pings and pongs are correct
according to the specification.</p>

<p>We can ask IVY to check this conclusion for us:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ivy_check trusted=true pingpong.ivy 
Checking isolate iso_l...
Checking isolate iso_r...
OK
</code></pre></div></div>

<p>The option <code class="language-plaintext highlighter-rouge">trusted=true</code> tells IVy to trust that the specified
isolates are correct, facts that we have tested, but not formally
verified. IVy says it can prove based on this assumption that all of
our assertions are true at all times.</p>

<h2 id="is-this-really-a-proof">Is this really a proof?</h2>

<p>In creating the two isolates <code class="language-plaintext highlighter-rouge">iso_l</code> and <code class="language-plaintext highlighter-rouge">iso_r</code>, we reduced a proof
goal to two simpler sub-goals. In theorem provers, this kind of
reduction is called a <em>tactic</em>.  We must take care that our tactics
are logically sound. That is, is the two sub-goals are provable, then
the original goal must also be provable.</p>

<p>Let’s try informally to justify the soundness of our tactic. Ivy
performed two transformations to produce each isolate: it changed some
assertions to assumptions, and it deleted the actions and state components of
one of the two players.</p>

<h1 id="pseudo-circular-proofs">Pseudo-circular proofs</h1>

<p>At first blush, changing assertions to assumptions seems to be unsound
because of a logical circularity. That is, we assumed <code class="language-plaintext highlighter-rouge">ping</code> to prove
<code class="language-plaintext highlighter-rouge">pong</code> and <code class="language-plaintext highlighter-rouge">pong</code> to prove <code class="language-plaintext highlighter-rouge">ping</code>. This apparent circularity is broken
by the fact that when proving <code class="language-plaintext highlighter-rouge">ping</code>, we only assume <code class="language-plaintext highlighter-rouge">pong</code> has been
correct <em>in the past</em>.  When verifying <code class="language-plaintext highlighter-rouge">iso_l</code>, we show that the
assertion about <code class="language-plaintext highlighter-rouge">ping</code> is not the first assertion to fail. When
verifying <code class="language-plaintext highlighter-rouge">iso_r</code>, we show that the assertion about <code class="language-plaintext highlighter-rouge">pong</code> is not the
first assertion to fail. Since no assertion is the first to fail, we
know no assertion ever fails (this is an argument by <a href="https://en.wikipedia.org/wiki/Mathematical_induction">induction</a> over time).</p>

<h1 id="abstraction">Abstraction</h1>

<p>In isolating the left player, IVy deleted all the actions and state
components of the right player. This is a form of abstraction known as
<em>localization</em>.  The idea is that the truth of some assertions does not
depend on certain components of the system. But in what cases is this
a sound abstraction? That is, when can we infer that an assertion is true
from the fact that it is true in the abstracted system? A sufficient
condition is that the abstracted actions can have no side effect that
is visible to the remaining actions. We will call this condition
<em>non-interference</em>.</p>

<p>IVy uses a fairly simple analysis to check non-interference. As an example,
suppose the right player tries to cheat by putting the ball back in 
the left player’s court without hitting it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object right_player = {

    ...

    implement intf.ping {
        left_player.ball := true
    }

    ...
}
</code></pre></div></div>

<p>Here’s what happens when when we try to verify this version:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ivy_check trusted=true interference.ivy 
Checking isolate iso_l...
interference.ivy: line 30: error: Call out to right_player.intf_ping[implement] may have visible effect on left_player.ball
interference.ivy: line 37: referenced here
interference.ivy: line 20: referenced here
interference.ivy: line 30: referenced here
interference.ivy: line 27: referenced here
</code></pre></div></div>

<p>IVy can’t abstract away the right player’s implementation of
<code class="language-plaintext highlighter-rouge">intf.ping</code> because of the possible side effect on <code class="language-plaintext highlighter-rouge">left_player.ball</code>.
IVy’s analysis of interference is based only on which state components
are referenced and assigned. It’s easy to construct an example where
two objects share a variable, but do not actually interfere, for
example, because they reference disjoint elements of an array. IVy
will flag this as an error, since its analysis is not precise enough
to show non-interference. IVy is designed to reason about objects that
share interfaces, but not variables.</p>

<h1 id="coverage">Coverage</h1>

<p>To be sound, our tactic must also ensure that every assertion in the
program is verified in some isolate. IVy checks this for us. Suppose, for example, we remove this
isolate declaration from our ping-pong program:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>isolate iso_r = right_player with spec
</code></pre></div></div>

<p>Here is what happens when we try to verify <a href="https://kenmcmil.github.io/examples/testing/coveragefail.ivy">the program</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ivy_check trusted=true  coveragefail.ivy
coveragefail.ivy: line 20: error: assertion is not checked
coveragefail.ivy: line 5: error: ...in action intf.pong
coveragefail.ivy: line 49: error: ...when called from right_player.hit
error: Some assertions are not checked
</code></pre></div></div>

<p>IVy is telling us that the precondition of action <code class="language-plaintext highlighter-rouge">pong</code> isn’t checked
when it’s called from <code class="language-plaintext highlighter-rouge">right_player</code>, because we haven’t created an
isolate for <code class="language-plaintext highlighter-rouge">right_player</code>.</p>

<h2 id="the-isolate-declaration">The isolate declaration</h2>

<p>Now let’s look at the <code class="language-plaintext highlighter-rouge">isolate</code> declaration in more detail. Here is the declaration
that isolates the left player:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>isolate iso_l = left_player with spec
</code></pre></div></div>

<p>This creates an isolate named <code class="language-plaintext highlighter-rouge">iso_l</code> in which the guarantees of <code class="language-plaintext highlighter-rouge">left_player</code> are
checked. The actions of all objects except for <code class="language-plaintext highlighter-rouge">left_player</code> and
<code class="language-plaintext highlighter-rouge">spec</code> are abstracted away (assuming they are non-interfering). If we
didn’t include <code class="language-plaintext highlighter-rouge">spec</code> in the <code class="language-plaintext highlighter-rouge">with</code> part of the declaration, then
<code class="language-plaintext highlighter-rouge">spec</code> would be abstracted away, and no assertions would be checked
(leading to an error message similar to the one above).</p>

<p>The remaining question is how IVy decides which assertions are
guarantees for <code class="language-plaintext highlighter-rouge">left_player</code> and which are assumptions. The default
rules are as follows.</p>

<p>A <em>guarantee</em> for a given object is any assertion occurring in:</p>

<ul>
  <li>An implementation provided by the object</li>
  <li>A <code class="language-plaintext highlighter-rouge">before</code> monitor of an action called by the object</li>
  <li>An <code class="language-plaintext highlighter-rouge">after</code> monitor of an implementation provided by the object</li>
</ul>

<p>An <em>assumption</em> for a given object is any assertion occurring in:</p>

<ul>
  <li>A <code class="language-plaintext highlighter-rouge">before</code> monitor of an implementation provided by the object</li>
  <li>An <code class="language-plaintext highlighter-rouge">after</code> monitor action called by the object</li>
</ul>

<p>(<code class="language-plaintext highlighter-rouge">after</code> specifications will be introduced in the next section).</p>

<p>This roughly corresponds to the intuition that an object makes
assumptions about its inputs and guarantees about its outputs.</p>

<h2 id="so-what-have-we-proved">So what have we proved?</h2>

<p>If all isolates are correct, and if IVy’s non-interference and
coverage checks succeed, then we can infer that all assertions in the
program are true at all times in all executions of the program. In
this case, <code class="language-plaintext highlighter-rouge">ivy_check</code> prints <code class="language-plaintext highlighter-rouge">OK</code>. Of course, we only verified the
isolates by randomized testing. This means there is a risk that we
missed a bug in a system component. Because IVy checked our
assume/guarantee proof, however, we know that if the whole system has
a bug, then one of the isolates must have a bug. If we test the
isolates long enough, we will eventually find it without testing the
system as a whole.</p>


	</div>
	
      </article>

    </div>

    <div class="unit one-fourth hide-on-mobiles">
  <aside>
    
    <h4>Documentation</h4>
    <ul>

  
  
  <li class=""><a href="../../install.html">Installing IVy</a></li>

  
  
  <li class=""><a href="../../language.html">The Ivy language</a></li>

  
  
  <li class=""><a href="../../commands.html">IVy command reference</a></li>

  
  
  <li class=""><a href="../../decidability.html">Decidability</a></li>

  
  
  <li class=""><a href="../../proving.html">IVy as a theorem prover</a></li>

</ul>

    
    <h4>IVy by example</h4>
    <ul>

  
  
  <li class=""><a href="../client_server_example.html">Invariants</a></li>

  
  
  <li class=""><a href="../specification.html">Specifications</a></li>

  
  
  <li class=""><a href="../datatypes.html">Abstract Datatypes</a></li>

  
  
  <li class=""><a href="../leader.html">Parameterized systems</a></li>

  
  
  <li class=""><a href="../helloworld.html">Hello, world!</a></li>

  
  
  <li class=""><a href="../networking.html">Networking</a></li>

  
  
  <li class=""><a href="../values.html">Concrete data</a></li>

  
  
  <li class=""><a href="../list_reverse.html">Deduction example: array reversal</a></li>

  
  
  <li class=""><a href="../indexset.html">Deduction example: majority</a></li>

  
  
  <li class=""><a href="../window.html">Example: sliding window</a></li>

  
  
  <li class=""><a href="../number_theory.html">Number theory</a></li>

</ul>

    
    <h4>Sharded Hash Table</h4>
    <ul>

  
  
  <li class=""><a href="../sht/sharded_hash_table.html">Introduction</a></li>

  
  
  <li class=""><a href="../sht/key.html">Keys</a></li>

  
  
  <li class=""><a href="../sht/shard.html">Shards</a></li>

  
  
  <li class=""><a href="../sht/table.html">Tables</a></li>

  
  
  <li class=""><a href="../sht/delmap.html">Delegation Map</a></li>

  
  
  <li class=""><a href="../sht/seqnum.html">Sequence Numbers</a></li>

  
  
  <li class=""><a href="../sht/queue.html">Message Queues</a></li>

  
  
  <li class=""><a href="../sht/trans.html">Transport Service</a></li>

  
  
  <li class=""><a href="../sht/reference.html">Reference object</a></li>

  
  
  <li class=""><a href="../sht/proto.html">Protocol</a></li>

  
  
  <li class=""><a href="../sht/sht.html">Final Assembly</a></li>

</ul>

    
    <h4>Compositional Testing</h4>
    <ul>

  
  
  <li class=""><a href="intro.html">Introduction</a></li>

  
  
  <li class="current"><a href="specification.html">Specifications</a></li>

  
  
  <li class=""><a href="leader.html">Layered protocols</a></li>

</ul>

    
  </aside>
</div>


    <div class="clear"></div>

  </div>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>IVy</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>
IVy is a research tool intended to allow interactive development of protocols and their proofs of correctness and to provide a platform for developing and experimenting with automated proof techniques. In particular, IVy provides interactive visualization of automated proofs, and supports a use model in which the human protocol designer and the automated tool interact to expose errors and prove correctness.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
