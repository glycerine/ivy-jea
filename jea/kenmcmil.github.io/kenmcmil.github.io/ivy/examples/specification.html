<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Specifications</title>
  <meta name="description" content="
IVy is a research tool intended to allow interactive development of protocols and their proofs of correctness and to provide a platform for developing and experimenting with automated proof techniques. In particular, IVy provides interactive visualization of automated proofs, and supports a use model in which the human protocol designer and the automated tool interact to expose errors and prove correctness.
">

  <link rel="stylesheet" href="../css/main.css">
  <link rel="canonical" href="https://microsoft.github.io/ivyhttps://kenmcmil.github.io/ivy/examples/specification.html">
  <link rel="alternate" type="application/rss+xml" title="IVy" href="https://microsoft.github.io/ivyhttps://kenmcmil.github.io/ivy/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://kenmcmil.github.io/">IVy</a>

    <nav class="site-nav">
      <a href="specification.html#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
          <a class="page-link" href="../credits.html">Credits</a>
          
        
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="../index.html">Home</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
          <div class="grid">
    
    <div class="unit three-fourths">


      <article class="post">

	<header class="post-header">
	  <h1 class="post-title">Specifications</h1>
	</header>

	<div class="post-content">
	  <p>Formal verification is primarily about establishing relationships
between specifications at differing levels of abstraction.</p>

<p>Consider, for example, a network protocol, such as the <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP
protocol</a>
that is widely used to communicate streams of data over the Internet.
At a high level of abstraction, TCP is a <em>service</em>, providing methods
for establishing connections, and sending or receive data. This
service provides guarantees to its users of reliable in-order
transmission of streams of bytes. At a lower level of abstraction, TCP
can be seen as a <em>protocol</em>. The protocol is a set of rules (laid out
in <a href="https://tools.ietf.org/html/rfc675">RFC 675</a> and later documents)
that implements service guarantees of TCP by exchanging datagrams
over an unreliable network.</p>

<p>The service and protocol specifications of TCP are views of the same
process observed at different interfaces. That is, TCP is sandwiched
between a higher-level application (say, a web browser and web server)
and the lower-level datagram protocol (typically the IP protocol) as shown below:</p>

<p><img src="../images/network_stack1.png" alt="Network Stack" /></p>

<p>The TCP service specification describes the events we observe at the
interface between the application layer and the transport layer.  The
IP service specification describes the events we observe at the
interface between the transport layer and the network layer.  The TCP
protocol specification describes the <em>relation</em> between events at this
interface and the lower-level interface between transport and network
layers.</p>

<p>If we were develping the TCP protocol specification, we would like to
verify that the IP service and the TCP protocol together implement the
TCP service specification. That is, if events at the transport/network
interface are consistent with the IP service specification, and if we
execute the TCP protocol according to its specification, then events
at the application/transport interface should be consistent with the TCP
service specification. From the point of view of the TCP protocol, we
say that the IP service specification is an <em>assumption</em>, while the
TCP service specification is a <em>guarantee</em>.</p>

<p>Ivy has features that allow us to perform this kind of reasoning. It allows us to:</p>

<ul>
  <li>Define objects with interfaces</li>
  <li>Write specifications about interfaces</li>
  <li>Prove assume/guarantee relationships between these specifications</li>
</ul>

<p>In Ivy, interfaces and specifications are objects. An interface is
object with unimplemented actions (a bit like an instance of an
abstract class in C++). A specification is a special object that
monitors the calls and returns across an interface.</p>

<h3 id="monitors-as-specifications">Monitors as specifications</h3>

<p>To specify services such as TCP, we need to make statements about the
<em>sequences</em> of events that can occur at an interface. For example, in
TCP, we need to make statements relating the sequences of send and
receive events to abstract data streams that are transmitted between
clients. Specifications about sequences of events in time are often
referred to as <em>temporal</em> specifications.</p>

<p>A common approach to tempral specification is to define a specialized
logical notation called a <a href="http://plato.stanford.edu/entries/logic-temporal"><em>temporal
logic</em></a>. These
notations make it possible to write succinct temporal specifications,
and also us to do some proofs in a fully automated way using <a href="http://www.loria.fr/~merz/papers/mc-tutorial.pdf">model
checking</a>.</p>

<p>For reasons we will discuss shortly, Ivy takes a different approach.
Temporal specifications in Ivy are defined using special objects
called <em>monitors</em>. A monitor is an object that synchronizes its
actions with calls and returns across an interface. This allows the
monitor to record information about the history of the interface in
its local state, and to assert facts that should be true about
inteface events based on the history of previous events.</p>

<p>As an example, here is a definition of an interface for a rediculously
simple network service:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#lang ivy1.7
type packet

object intf = {
    action send(x:packet)
    action recv(x:packet)
}
</code></pre></div></div>

<p>The actions in an interface object don’t have definitions. These will
be filled in by other objects that implement the different roles in
the interface. We don’t know yet what these objects actually do, but
we can write a service specification that tells us something about the
temporal behavior at the interface:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>specification {

    relation sent(X:packet)

    after init {
        sent(X) := false
    }

    before intf.send {
        sent(x) := true
    }

    before intf.recv {
        require sent(x)
    }
}
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">specification</code> section contains a monitor. This is imaginary code that is not
normally executed (often referred to as “ghost” code).
The monitor has one local state
component <code class="language-plaintext highlighter-rouge">sent</code> that records the set of packets that have been sent
so far. This information is recorded by inserting an action <em>before</em>
every call to <code class="language-plaintext highlighter-rouge">intf.send</code>. This is done using a new declaration
<code class="language-plaintext highlighter-rouge">before</code>. Notice that the inserted action can refer to the parameters
of <code class="language-plaintext highlighter-rouge">intf.send</code> and it can update the monitor state.  In addition, the
monitor inserts an assertion before every call to <code class="language-plaintext highlighter-rouge">intf.recv</code>. This
assertion is introduced with the <code class="language-plaintext highlighter-rouge">require</code> statement. This means that
the calling environment of <code class="language-plaintext highlighter-rouge">inft.recv</code> must guarantee that the
condition <code class="language-plaintext highlighter-rouge">sent(x)</code> holds before the call to <code class="language-plaintext highlighter-rouge">intf.send</code>. That is, the
received packet <code class="language-plaintext highlighter-rouge">x</code> must previously have been sent.</p>

<p>In effect, our service specification describes a channel that can
re-order and duplicate packets, but cannot corrupt packets. If any
corrupted packet is received, the assertion will fail.</p>

<p>Now let’s consider some possible implementations of this very simple
specification. Here is the most trivial one:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>implementation {
    implement intf.send {
        call intf.recv(x)
    }
}
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">implementation</code> section provides the implementation of action <code class="language-plaintext highlighter-rouge">intf.send</code>
using a new declaration <code class="language-plaintext highlighter-rouge">implement</code>. This declaration provides the
missing body of the action <code class="language-plaintext highlighter-rouge">intf.send</code>. The implementation simply calls <code class="language-plaintext highlighter-rouge">intf.recv</code>
on the sent packet <code class="language-plaintext highlighter-rouge">x</code>. The assertion in the monitor is always
true, since before calling <code class="language-plaintext highlighter-rouge">intf.send</code>, the packet <code class="language-plaintext highlighter-rouge">x</code> is added to the
relation <code class="language-plaintext highlighter-rouge">sent</code>. That is, our implementation trivially satisfies the
specification “receive only sent packets”.</p>

<p>To verify our implementation, we need to put it in a suitable
environment. The following statements tell us that the environment
will implement <code class="language-plaintext highlighter-rouge">intf.recv</code> and will call <code class="language-plaintext highlighter-rouge">intf.send</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import intf.recv
export intf.send
</code></pre></div></div>

<p>Now, saving this text in the file <code class="language-plaintext highlighter-rouge">trivnet.ivy</code>, we can check that our
“protocol” satisfies its service specification like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ivy_check trivnet.ivy

Isolate this:

    The following action implementations are present:
        trivnet.ivy: line 6: implementation of intf.recv
        trivnet.ivy: line 28: implementation of intf.send

    The following action monitors are present:
        trivnet.ivy: line 21: monitor of intf.recv
        trivnet.ivy: line 17: monitor of intf.send

    The following initializers are present:
        trivnet.ivy: line 13: init[after1]

    Any assertions in initializers must be checked ... PASS

    The following program assertions are treated as guarantees:
        in action intf.recv when called from intf.send:
            trivnet.ivy: line 21: guarantee ... PASS

OK
</code></pre></div></div>

<p>For the moment, ignore the mysterious heading ‘Isolate this:’. 
Ivy checked that the precondition of <code class="language-plaintext highlighter-rouge">intf.recv</code> is true whenever it
is called by <code class="language-plaintext highlighter-rouge">intf.send</code>. We don’t even need an inductive invariant in
this case, because the assertion is true when <code class="language-plaintext highlighter-rouge">intf.send</code> is executed
in any context.</p>

<p>To get a better idea of what is happening with <code class="language-plaintext highlighter-rouge">before</code> and
<code class="language-plaintext highlighter-rouge">implements</code>, we can print out the program that results from inserting
the monitor actions and interface implementations:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ivy_show trivnet.ivy

type packet
relation sent(V0:packet)


after init {
    sent(X) := false
}
action intf.recv(x:packet) = {
    assert sent(x)
}
action intf.send(x:packet) = {
    {
        sent(x) := true;
        call intf.recv(x)
    }
}
export intf.send
</code></pre></div></div>

<p>Notice that the <code class="language-plaintext highlighter-rouge">before</code> actions of the monitor have been inserted at
the beginning of these actions, and the <code class="language-plaintext highlighter-rouge">implement</code> action of
<code class="language-plaintext highlighter-rouge">protocol</code> has been used as the body of <code class="language-plaintext highlighter-rouge">intf.send</code>. Notice also that
the <code class="language-plaintext highlighter-rouge">require</code> statement in the monitor has become <code class="language-plaintext highlighter-rouge">assert</code>. This means
that when <code class="language-plaintext highlighter-rouge">intf.recv</code> is called by our implementation, we have to
<em>prove</em> that the condition holds.</p>

<p>Of course, we might consider a (slightly) less trivial implementation,
such as this one that implements the service specification with a
one-place buffer:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>implementation {

    individual full : bool
    individual contents : packet

    after init {
        full := false;
    }

    implement intf.send {
        full := true;
        contents := x
    }

    action async = {
        if full {
            full := false;
            call intf.recv(contents)
        }
    }
}
</code></pre></div></div>

<p>This implementation has an action <code class="language-plaintext highlighter-rouge">async</code> that needs to be called by the
environment, so we add:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export async
</code></pre></div></div>

<p>When <code class="language-plaintext highlighter-rouge">async</code> is called, if there is a message in the buffer, the message
is received. 
To verify this implementation, we also need one invariant conjecture:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>invariant full -&gt; sent(contents)
</code></pre></div></div>

<p>That is, to show that when <code class="language-plaintext highlighter-rouge">async</code> executes, the received packet has
been sent, we need to know that the packet in the buffer has been
sent. The reader might want to try to produce this invariant using the
<a href="client_server_example.html">interactive invariant generation
techniques</a> supported by Ivy.</p>

<h3 id="assume-guarantee-reasoning-in-ivy">Assume-Guarantee reasoning in Ivy</h3>

<p>In the previous example, we saw that a service specification is a kind
of abstraction. It hides details of the underlying imlementation,
telling us only what we need to know to use the service. Abstractions
are crucial in reasoning about complex systems. They allow us to
develop one component of a system without thinking about the details
of the implementation of other components. For example, when
developing a network application based on TCP, we don’t have to read
RFC 675. We just rely on the simple service guarantee that TCP
provides (reliable, in-order delivery). The service specification
allows us to think about our application in <em>isolation</em> from the
network protocol stack.</p>

<p>Ivy provides a mechanism to do just this when proving correctness of
system components. That is, we can isolate a single object in our
system and prove its correctness using only the service specifications
of its interfaces.</p>

<p>As an example, let’s build a system of two components that plays a
highly simplified game of ping-pong. Here is the interface definition:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#lang ivy1.5

object intf = {
    action ping
    action pong
}
</code></pre></div></div>

<p>Here is the interface specification:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type side_t = {left,right}

specification {
    individual side : side_t
    after init {
        side := left
    }

    before intf.ping {
        require side = left;
        side := right
    }

    before intf.pong {
        require side = right;
        side := left
    }
}
</code></pre></div></div>

<p>The specification section has a single state component <code class="language-plaintext highlighter-rouge">side</code> that keeps track
of whether the ball is on the left- or right-hand side of the
table. When the ball is on the left, a <code class="language-plaintext highlighter-rouge">ping</code> action is allowed,
sending the ball to the right-hand side.  When the ball is on the
right, a <code class="language-plaintext highlighter-rouge">pong</code> is allowed, sending the ball to the left again.  A
failure to alternate <code class="language-plaintext highlighter-rouge">ping</code> and <code class="language-plaintext highlighter-rouge">pong</code> would cause one of the
preconditions to fail.</p>

<p>Now let’s implement the left-hand player:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>implementation {
    isolate left_player = {
        individual ball : bool
        after init {
            ball := true
        }

        action hit = {
            if ball {
                call intf.ping;
                ball := false
            }
        }

        implement intf.pong {
            ball := true
        }

        invariant ball -&gt; side = left
    } with this
}
</code></pre></div></div>

<p>The left player is a special kind of object called an <code class="language-plaintext highlighter-rouge">isolate</code>. An
isolate is verified in isolation.  The player has a Boolean state
variable <code class="language-plaintext highlighter-rouge">ball</code> that indicates the ball is in the player’s court. We
assume the left player serves, so <code class="language-plaintext highlighter-rouge">ball</code> is initially true. If the
left player has the ball, the <code class="language-plaintext highlighter-rouge">hit</code> action will call <code class="language-plaintext highlighter-rouge">ping</code>, sending
the ball to the right, and set <code class="language-plaintext highlighter-rouge">ball</code> to false.  The left player
implements <code class="language-plaintext highlighter-rouge">ping</code> by setting <code class="language-plaintext highlighter-rouge">ball</code> to true (for the moment, ignore
the invariant, and also the declaration <code class="language-plaintext highlighter-rouge">with this</code>).</p>

<p>The right-hand player implementation is similar, except that it
reverses the roles of <code class="language-plaintext highlighter-rouge">ping</code> and <code class="language-plaintext highlighter-rouge">pong</code>, and initially its <code class="language-plaintext highlighter-rouge">ball</code>
variable is false:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>implementation {
    isolate right_player = {
        individual ball : bool
        after init {
            ball := false
        }

        action hit = {
            if ball {
                call intf.pong;
                ball := false
            }
        }

        implement intf.ping {
            ball := true
        }

        invariant ball -&gt; side = right
    } with this
}
</code></pre></div></div>

<p>Let’s export the <code class="language-plaintext highlighter-rouge">hit</code> actions to the environment, so the players
will do something:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export left_player.hit
export right_player.hit
</code></pre></div></div>

<p>At this point we could easily enough verify the assertions using the
given invariant conjectures. However, by using <code class="language-plaintext highlighter-rouge">isolate</code> declarations,
we separate the reasoning about the left and right players, using the
top-level specification.  The top-level program is also an isolate,
called <code class="language-plaintext highlighter-rouge">this</code>. Each player isolate draws its assumptions and
guarantees from the the top-level specification. For this reason, each
is given a declaration <code class="language-plaintext highlighter-rouge">with this</code>.</p>

<p>We now have two separate proof problems, one for each player isolate.
We can see what the left player isolate looks like as
follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ivy_show isolate=left_player pingpong.ivy

type side_t = {left,right}
individual side : {left,right}
relation left_player.ball

invariant [left_player.invar6] left_player.ball -&gt; side = left

after init {
    side := left
}
after init {
    left_player.ball := true
}
action intf.ping = {
    assert side = left;
    side := right
}
action left_player.hit = {
    if left_player.ball {
        call intf.ping;
        left_player.ball := false
    }
}
action intf.pong = {
    {
        assume side = right;
        side := left;
        left_player.ball := true
    }
}
export intf.pong
export left_player.hit
</code></pre></div></div>

<p>Several interesting things have happened here. First, notice the the
action <code class="language-plaintext highlighter-rouge">intf.ping</code>. We see that the code inserted by the monitor is
present, but the implementation provided by <code class="language-plaintext highlighter-rouge">right_player</code> is missing.
In effect, the right player has been abstracted away: we see neither
its state nor its actions.  Further, notice that the action <code class="language-plaintext highlighter-rouge">pong</code> has
been exported to the environment. It contains the monitor code from
the top-level specification and also the left player’s implementation of <code class="language-plaintext highlighter-rouge">pong</code>. There is a
crucial change, however: the <code class="language-plaintext highlighter-rouge">require</code> in the specification of <code class="language-plaintext highlighter-rouge">pong</code>
has changed to <code class="language-plaintext highlighter-rouge">assume</code>.</p>

<p>This is an example of assume-guarantee reasoning. The left player
<em>guarantees</em> to call <code class="language-plaintext highlighter-rouge">ping</code> only when the ball is on the
left. However, it <em>assumes</em> that the right player only calls <code class="language-plaintext highlighter-rouge">ping</code>
when the ball is on the right. This is a very common situation in protocols. 
Each participant in the protocol guarantees correctness of its outputs,
but only so long as its inputs are correct.</p>

<p>Finally, notice that the isolate contains only the left player’s invariant
conjecture. Using this invariant, we can prove the correctness of <code class="language-plaintext highlighter-rouge">ping</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ivy_check isolate=left_player pingpong.ivy

Isolate left_player:

    ...

    The following set of external actions must preserve the invariant:
        (internal) ext:intf.pong
            pingpong.ivy: line 45: left_player.invar6 ... PASS
        (internal) ext:left_player.hit
            pingpong.ivy: line 45: left_player.invar6 ... PASS

    The following program assertions are treated as assumptions:
        in action intf.pong when called from the environment:
            pingpong.ivy: line 22: assumption

    The following program assertions are treated as guarantees:
        in action intf.ping when called from left_player.hit:
            pingpong.ivy: line 17: guarantee ... PASS

OK
</code></pre></div></div>

<p>We’ve shown only some interesting parts of Ivy’s ouput. Notice first
that Ivy verifies that the two exported actions of the left player
isolate preserve the invariant conjecture of <code class="language-plaintext highlighter-rouge">left_player</code>. These are <code class="language-plaintext highlighter-rouge">intf.pong</code> and
<code class="language-plaintext highlighter-rouge">left_player.hit</code>. In addition, notice that Ivy treated the
precondition of <code class="language-plaintext highlighter-rouge">intf.pong</code> as an <em>assumption</em>, and the precondition
of <code class="language-plaintext highlighter-rouge">intf.ping</code> as a <em>guarantee</em>. It checked the guarantee given the
assumption and printed PASS to indicate the the guarantee holds.</p>

<p>Now let’s look at the other isolate:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ivy_show isolate=right_player pingpong.ivy

type side_t = {left,right}
individual side : {left,right}
relation right_player.ball

invariant [right_player.invar9] right_player.ball -&gt; side = right

after init {
    side := left
}
after init {
    right_player.ball := false
}
action intf.pong = {
    assert side = right;
    side := left
}
action right_player.hit = {
    if right_player.ball {
        call intf.pong;
        right_player.ball := false
    }
}
action intf.ping = {
    {
        assume side = left;
        side := right;
        right_player.ball := true
    }
}
export intf.ping
export right_player.hit
</code></pre></div></div>

<p>This is similar, but now <code class="language-plaintext highlighter-rouge">pong</code> is verified and <code class="language-plaintext highlighter-rouge">ping</code> is assumed to be correct.
The state and actions of the left player are compeltely abstracted away.</p>

<p>We can check the whole proof using Ivy like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ivy_check pingpong.ivy 

...

Isolate right_player:

    ...

    The following set of external actions must preserve the invariant:
        (internal) ext:intf.ping
            pingpong.ivy: line 65: right_player.invar9 ... PASS
        (internal) ext:right_player.hit
            pingpong.ivy: line 65: right_player.invar9 ... PASS

    The following program assertions are treated as assumptions:
        in action intf.ping when called from the environment:
            pingpong.ivy: line 17: assumption

    The following program assertions are treated as guarantees:
        in action intf.pong when called from right_player.hit:
            pingpong.ivy: line 22: guarantee ... PASS

...

OK
</code></pre></div></div>

<p>Notice here, the assume/guarantee relation is reversed. We assume the
precondition of <code class="language-plaintext highlighter-rouge">intf.ping</code> when proving the precondition of
<code class="language-plaintext highlighter-rouge">intf.pong</code>.</p>

<h2 id="is-this-really-a-proof">Is this really a proof?</h2>

<p>In creating the two isolates <code class="language-plaintext highlighter-rouge">left_player</code> and <code class="language-plaintext highlighter-rouge">right_player</code>, we
reduced a proof goal to two simpler sub-goals. In theorem provers,
this kind of reduction is called a <em>tactic</em>.  We must take care that
our tactics are logically sound. That is, is the two sub-goals are
provable, then the original goal must also be provable.</p>

<p>Let’s try informally to justify the soundness of our tactic. Ivy
performed two transformations to produce each isolate: it changed some
requiremens to assumptions or assertions, and it deleted the code of
one of the two players.</p>

<h1 id="pseudo-circular-proofs">Pseudo-circular proofs</h1>

<p>At first blush, changing assertions to assumptions seems to be unsound
because of a logical circularity. That is, we assumed <code class="language-plaintext highlighter-rouge">ping</code> to prove
<code class="language-plaintext highlighter-rouge">pong</code> and <code class="language-plaintext highlighter-rouge">pong</code> to prove <code class="language-plaintext highlighter-rouge">ping</code>. This apparent circularity is broken
by the fact that when proving <code class="language-plaintext highlighter-rouge">ping</code>, we only assume <code class="language-plaintext highlighter-rouge">pong</code> has been
correct <em>in the past</em>.  When verifying <code class="language-plaintext highlighter-rouge">left_player</code>, we show that the
assertion about <code class="language-plaintext highlighter-rouge">ping</code> is not the first assertion to fail. When
verifying <code class="language-plaintext highlighter-rouge">right_player</code>, we show that the assertion about <code class="language-plaintext highlighter-rouge">pong</code> is not the
first assertion to fail. Since no assertion is the first to fail, we
know no assertion ever fails.</p>

<h1 id="abstraction">Abstraction</h1>

<p>In isolating the left player, Ivy deleted all the actions and state
components of the right player. This is a form of abstraction known as
<em>localization</em>.  The idea is that the truth of some assertions does not
depend on certain components of the system. But in what cases is this
a sound abstraction? That is, when can we infer that an assertion is true
from the fact that it is true in the abstracted system? A sufficient
condition is that the abstracted actions can have no side effect that
is visible to the remaining actions. We will call this condition
<em>non-interference</em>.</p>

<p>Ivy uses a fairly simple analysis to check non-interference. As an example,
suppose the right player tries to cheat by putting the ball back in 
the left player’s court without hitting it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>isolate right_player = {

    ...

    implement intf.ping {
        left_player.ball := true
    }

    ...
}
</code></pre></div></div>

<p>Here’s what happens when when we try to verify this version:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ivy_check interference.ivy

Isolate left_player:
interference.ivy: line 30: error: Call out to intf.ping may have visible effect on left_player.ball
</code></pre></div></div>

<p>Ivy can’t abstract away the right player’s implementation of
<code class="language-plaintext highlighter-rouge">intf.ping</code> because of the possible side effect on <code class="language-plaintext highlighter-rouge">left_player.ball</code>.
Ivy’s analysis of interference is based only on which state components
are referenced and assigned. It’s easy to construct an example where
two objects share a variable, but do not actually interfere, for
example, because they reference disjoint elements of an array. Ivy
will flag this as an error, since its analysis is not precise enough
to show non-interference. Ivy is designed to reason about objects that
share interfaces, but not variables.</p>

<h1 id="coverage">Coverage</h1>

<p>To be sound, our tactic must also ensure that every assertion in the
program is verified in some isolate. Ivy checks this for us. Suppose, for example, we remove the
<code class="language-plaintext highlighter-rouge">with this</code> declaration from the <code class="language-plaintext highlighter-rouge">right_player</code> isolate.
Here is what happens when we try to verify the program:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ivy_check coveragefail.ivy
coveragefail.ivy: line 20: error: assertion is not checked
coveragefail.ivy: line 5: error: ...in action intf.pong
coveragefail.ivy: line 49: error: ...when called from right_player.hit
error: Some assertions are not checked
</code></pre></div></div>

<p>Ivy is telling us that the precondition of <code class="language-plaintext highlighter-rouge">pong</code> assertion isn’t checked, because we
haven’t declared the top-level specification as a dependency of <code class="language-plaintext highlighter-rouge">right_player</code>.</p>

<h2 id="the-isolate-declaration">The isolate declaration</h2>

<p>Now let’s look at the <code class="language-plaintext highlighter-rouge">isolate</code> declaration in more detail. Here is the declaration
of the <code class="language-plaintext highlighter-rouge">left_player</code> isolate:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>isolate left_player = {
    ...
} with this
</code></pre></div></div>

<p>This creates an isolate named <code class="language-plaintext highlighter-rouge">left_player</code> in whose guarantees are
checked in contect of the top-level isolate’s specification.
In this process, the actions of all isolates except for <code class="language-plaintext highlighter-rouge">left_player</code> and
<code class="language-plaintext highlighter-rouge">this</code> are erased (assuming they are non-interfering). If we
didn’t include <code class="language-plaintext highlighter-rouge">this</code> in the <code class="language-plaintext highlighter-rouge">with</code> part of the declaration, then
<code class="language-plaintext highlighter-rouge">this</code> would be abstracted away, and no assertions would be checked
(leading to an error message similar to the one above).</p>

<p>The remaining question is how Ivy decides which assertions are
guarantees for <code class="language-plaintext highlighter-rouge">left_player</code> and which are assumptions. The default
rules are as follows.</p>

<p>A <em>guarantee</em> for a given isolate is:</p>

<ul>
  <li>a <code class="language-plaintext highlighter-rouge">require</code> assertion in another isolate it calls into, or</li>
  <li>an <code class="language-plaintext highlighter-rouge">ensure</code> assertion of the isolate itself.</li>
</ul>

<p>An <em>assumption</em> for a given object is:</p>

<ul>
  <li>a <code class="language-plaintext highlighter-rouge">require</code> assertion of the isolate itself, or</li>
  <li>a <code class="language-plaintext highlighter-rouge">ensure</code> assertion of an isolate it calls into.</li>
</ul>

<p>(<code class="language-plaintext highlighter-rouge">after</code> monitors and <code class="language-plaintext highlighter-rouge">ensure</code> assertions will be introduced in the next section).</p>

<p>This roughly corresponds to the intuition that an object makes
assumptions about its inputs and guarantees about its outputs.</p>

<h2 id="what-we-prove">What we prove</h2>

<p>If all isolates are verified, and if Ivy’s non-interference and
coverage checks succeed, then we can infer that all assertions in the
program are true at all times in all executions of the program.  In
this case, <code class="language-plaintext highlighter-rouge">ivy_check</code> prints <code class="language-plaintext highlighter-rouge">OK</code>.</p>


	</div>
	
      </article>

    </div>

    <div class="unit one-fourth hide-on-mobiles">
  <aside>
    
    <h4>Documentation</h4>
    <ul>

  
  
  <li class=""><a href="../install.html">Installing IVy</a></li>

  
  
  <li class=""><a href="../language.html">The Ivy language</a></li>

  
  
  <li class=""><a href="../commands.html">IVy command reference</a></li>

  
  
  <li class=""><a href="../decidability.html">Decidability</a></li>

  
  
  <li class=""><a href="../proving.html">IVy as a theorem prover</a></li>

</ul>

    
    <h4>IVy by example</h4>
    <ul>

  
  
  <li class=""><a href="client_server_example.html">Invariants</a></li>

  
  
  <li class="current"><a href="specification.html">Specifications</a></li>

  
  
  <li class=""><a href="datatypes.html">Abstract Datatypes</a></li>

  
  
  <li class=""><a href="leader.html">Parameterized systems</a></li>

  
  
  <li class=""><a href="helloworld.html">Hello, world!</a></li>

  
  
  <li class=""><a href="networking.html">Networking</a></li>

  
  
  <li class=""><a href="values.html">Concrete data</a></li>

  
  
  <li class=""><a href="list_reverse.html">Deduction example: array reversal</a></li>

  
  
  <li class=""><a href="indexset.html">Deduction example: majority</a></li>

  
  
  <li class=""><a href="window.html">Example: sliding window</a></li>

  
  
  <li class=""><a href="number_theory.html">Number theory</a></li>

</ul>

    
    <h4>Sharded Hash Table</h4>
    <ul>

  
  
  <li class=""><a href="sht/sharded_hash_table.html">Introduction</a></li>

  
  
  <li class=""><a href="sht/key.html">Keys</a></li>

  
  
  <li class=""><a href="sht/shard.html">Shards</a></li>

  
  
  <li class=""><a href="sht/table.html">Tables</a></li>

  
  
  <li class=""><a href="sht/delmap.html">Delegation Map</a></li>

  
  
  <li class=""><a href="sht/seqnum.html">Sequence Numbers</a></li>

  
  
  <li class=""><a href="sht/queue.html">Message Queues</a></li>

  
  
  <li class=""><a href="sht/trans.html">Transport Service</a></li>

  
  
  <li class=""><a href="sht/reference.html">Reference object</a></li>

  
  
  <li class=""><a href="sht/proto.html">Protocol</a></li>

  
  
  <li class=""><a href="sht/sht.html">Final Assembly</a></li>

</ul>

    
    <h4>Compositional Testing</h4>
    <ul>

  
  
  <li class=""><a href="testing/intro.html">Introduction</a></li>

  
  
  <li class=""><a href="testing/specification.html">Specifications</a></li>

  
  
  <li class=""><a href="testing/leader.html">Layered protocols</a></li>

</ul>

    
  </aside>
</div>


    <div class="clear"></div>

  </div>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>IVy</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>
IVy is a research tool intended to allow interactive development of protocols and their proofs of correctness and to provide a platform for developing and experimenting with automated proof techniques. In particular, IVy provides interactive visualization of automated proofs, and supports a use model in which the human protocol designer and the automated tool interact to expose errors and prove correctness.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
