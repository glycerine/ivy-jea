<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Concrete data</title>
  <meta name="description" content="
IVy is a research tool intended to allow interactive development of protocols and their proofs of correctness and to provide a platform for developing and experimenting with automated proof techniques. In particular, IVy provides interactive visualization of automated proofs, and supports a use model in which the human protocol designer and the automated tool interact to expose errors and prove correctness.
">

  <link rel="stylesheet" href="../css/main.css">
  <link rel="canonical" href="https://microsoft.github.io/ivyhttps://kenmcmil.github.io/ivy/examples/values.html">
  <link rel="alternate" type="application/rss+xml" title="IVy" href="https://microsoft.github.io/ivyhttps://kenmcmil.github.io/ivy/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://kenmcmil.github.io/">IVy</a>

    <nav class="site-nav">
      <a href="values.html#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
          <a class="page-link" href="../credits.html">Credits</a>
          
        
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="../index.html">Home</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
          <div class="grid">
    
    <div class="unit three-fourths">


      <article class="post">

	<header class="post-header">
	  <h1 class="post-title">Concrete data</h1>
	</header>

	<div class="post-content">
	  <p>Abstract dataypes allow us to hide the representation of data behind
interfaces. To pass information across interfaces, however, we still
need a sufficiently rich class of concrete datatypes whose
representation is not hidden. This is particularly relevant when
communicating across a network. In this case, we can’t efficiently
pass a reference to an abstract object – we have to represent the
contents of the object in a concrete way.</p>

<p>To facilitate exchange of data across interfaces, Ivy provides a set of
standard concrete datatypes.</p>

<h1 id="structs">Structs</h1>

<p>A <code class="language-plaintext highlighter-rouge">struct</code> is an aggregate of named components. Structs are declared like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type point = struct {
    x : coord,
    y : coord
}
</code></pre></div></div>

<p>This defines a type <code class="language-plaintext highlighter-rouge">point</code> whose elements are structures consisting
of members <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> of type <code class="language-plaintext highlighter-rouge">coord</code>. Two <em>destructor</em> functions <code class="language-plaintext highlighter-rouge">x</code>
and <code class="language-plaintext highlighter-rouge">y</code> are defined that respectively extract the <em>x</em> and <em>y</em>
coordinates of the point. Thus, if <code class="language-plaintext highlighter-rouge">p</code> is a point, then <code class="language-plaintext highlighter-rouge">x(p)</code> is the
<em>x</em> coordinate of <code class="language-plaintext highlighter-rouge">p</code> and <code class="language-plaintext highlighter-rouge">y(p)</code> is the <em>y</em> coordinate.</p>

<p>The members of a structure can be assigned. For example, to assign <code class="language-plaintext highlighter-rouge">0</code> to
the <em>x</em> coordinate of point <code class="language-plaintext highlighter-rouge">p</code>, we would write:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x(p) := 0
</code></pre></div></div>

<p>This mutates not the destructor function <code class="language-plaintext highlighter-rouge">x</code>, which is immutable, but
rather the value of <code class="language-plaintext highlighter-rouge">p</code>. The value of <code class="language-plaintext highlighter-rouge">y(p)</code> remains unchanged by this
assignment.</p>

<p>Members of a struct can also be functions and relations. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type point = struct {
    coords(X:dimension) : nat
}
</code></pre></div></div>

<p>Our points now have one coordinate value for each dimension defined by
some arbitrary type <code class="language-plaintext highlighter-rouge">dimension</code>. Suppose we declare:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type dimension = {x,y,z}
</code></pre></div></div>

<p>We could then refer to the <code class="language-plaintext highlighter-rouge">x</code> coordinate of a point <code class="language-plaintext highlighter-rouge">p</code> as
<code class="language-plaintext highlighter-rouge">coord(p,x)</code>, and we could assign <code class="language-plaintext highlighter-rouge">0</code> to it like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>coord(p,x) := 0
</code></pre></div></div>

<p>This would be written in many programming languages as something like
<code class="language-plaintext highlighter-rouge">p.coord[x] = 0</code>. The type <code class="language-plaintext highlighter-rouge">dimension</code> need not be an enumerated type,
however. It could be an uninterpreted type, or an interpreted type
(for example, an integer type) or even another structure type.</p>

<p>Structs can also contain structs. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type line = {
    begin : point,
    end : point
}
</code></pre></div></div>

<p>To set the <em>x</em> coordinate of the begin point of a line <code class="language-plaintext highlighter-rouge">l</code>, we could write:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>coord(begin(l),x) := 0
</code></pre></div></div>

<p>This mutates <code class="language-plaintext highlighter-rouge">l</code> and not the immutable destructor functions <code class="language-plaintext highlighter-rouge">coord</code>
and <code class="language-plaintext highlighter-rouge">begin</code>.</p>

<h1 id="arrays">Arrays</h1>

<p>An array type represents a map from an interval <code class="language-plaintext highlighter-rouge">[0,end)</code> of some type
(the index type) to some other type (that value type). Usually the
index type is interpreted as <code class="language-plaintext highlighter-rouge">int</code>.</p>

<p>Here is an example of a simple program that tabulates the function
<code class="language-plaintext highlighter-rouge">f(X) = X * X</code> from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">max-1</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#lang ivy1.7

include collections

type t

instance arr : array(t,t)

action tabulate(max : t) returns (res:arr.t) {
    local i:index {
        i := 0;
        res := arr.create(max,0);
        while i &lt; max {
            res := arr.set(res,i,i*i);
            i := i + 1
        }
    }
}
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">array</code> module provides an action <code class="language-plaintext highlighter-rouge">create</code> that returns an array
mapping values in the range <code class="language-plaintext highlighter-rouge">[0,end)</code> to some given value (in the
example, <code class="language-plaintext highlighter-rouge">0</code>). The <code class="language-plaintext highlighter-rouge">set</code> action takes a array, an index and a
value. It sets the value of the array at the given index to the value
and returns the resulting array. Keep in mind, because of IVy’s
call-by-value convention, an action can’t have a side effect on its
input parameters. The <code class="language-plaintext highlighter-rouge">set</code> action returns a <em>copy</em> of its input
array with one value changed.</p>

<p>This program seems inefficient, since it copies the array each time it
modifies one element. In fact it isn’t. The compiler recognizes that
the array can be modified “in place”. Lets run this program to see
what we get.  First, we have to give a concrete interpretation for
type <code class="language-plaintext highlighter-rouge">t</code> and define an extract:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interpret t -&gt; int
export tabulate
extract iso_impl = tabulate, arr
</code></pre></div></div>

<p>Compile and run:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ make array1
ivy_to_cpp target=repl isolate=iso_impl array1.ivy
g++ -g -o array1 array1.cpp
$ ./array1
&gt; tabulate(4)
[0,1,4,9]
</code></pre></div></div>

<p>Here is a part of the interface definition for array types, from the
<code class="language-plaintext highlighter-rouge">collections</code> module in the standard library:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module array(domain,range) = {

    type t

    action create(s:domain,y:range) returns (a:t)
    action set(a:t,x:domain,y:range) returns (a:t)
    action get(a:t,x:domain) returns (y:range) 
    action size(a:t) returns (s:domain)
    action resize(a:t,s:domain,v:range) returns (a:t)

    function end(A:t) : domain
    function value(A:t,X:domain) : range

    object spec = {
        before create {
            assert 0 &lt;= s
        }
        after create {
            assert end(a) = s &amp; value(a,X) = y
        }
        before set {
            assert 0 &lt;= x &amp; x &lt; end(a)
        }                        
        after set {
            assert value(a,X) = y if X = x else value(old a,X)
        }
        before get {
            assert 0 &lt;= x &amp; x &lt; end(a)
        }
        after get {
            assert value(a,x) = y
        }
        after size {
            assert s = end(a)
        }
        after resize {
            assert end(a) = s;
            assert 0 &lt;= X &amp; X &lt; end(old a) -&gt; value(a,X) = value(old a,X);
            assert end(old a) &lt;= X &amp; X &lt; s -&gt; value(a,X) = v
        }
        ...
    }
    ...
}
</code></pre></div></div>

<p>In addition to <code class="language-plaintext highlighter-rouge">create</code> and <code class="language-plaintext highlighter-rouge">set</code>, array types provide an action <code class="language-plaintext highlighter-rouge">get</code>
to get the value at a given index, <code class="language-plaintext highlighter-rouge">size</code> to get the <code class="language-plaintext highlighter-rouge">end</code> index, and <code class="language-plaintext highlighter-rouge">resize</code>
to change the end index. The <code class="language-plaintext highlighter-rouge">resize</code> action takes an addition parameter
that gives the value of the new elements in case the size is increased.</p>

<p>Notice that in the <code class="language-plaintext highlighter-rouge">set</code> method, both the input and the output
parameter are called <code class="language-plaintext highlighter-rouge">a</code>. This indicates to the compiler that we
intend to modify the array <code class="language-plaintext highlighter-rouge">a</code> in place if possible. When writing the
<code class="language-plaintext highlighter-rouge">after</code> specification for <code class="language-plaintext highlighter-rouge">set</code>, we need a way to refer to the input
value of <code class="language-plaintext highlighter-rouge">a</code>. For this, we use <code class="language-plaintext highlighter-rouge">old a</code>. We can refer to the original
value of any component that is mutated by an action using <code class="language-plaintext highlighter-rouge">old</code>. You
can also see the use of <code class="language-plaintext highlighter-rouge">old</code> in the specification of <code class="language-plaintext highlighter-rouge">resize</code>. The
expression <code class="language-plaintext highlighter-rouge">old x</code> always referes to the value of symbol <code class="language-plaintext highlighter-rouge">x</code> at the
time the action was called.</p>

<p>In the next section, we’ll see a more interesting application of
arrays.</p>

<h1 id="representation-functions">Representation functions</h1>

<p>Often, we use concrete dataypes as representations of abstract values.
This gives us an efficient way of passing these values across
interfaces.</p>

<p>As an example, consider using an array as a representation of a
set. Here is the start of a module that accomplishes that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#lang ivy1.7
module set(elem) = {

    type this
    alias t = this

    relation contains(X:t,Y:elem)
    action emptyset returns(s:t)
    action add(s:t,e:elem) returns (s:t)
    ...    
</code></pre></div></div>

<p>Notice something new here: <code class="language-plaintext highlighter-rouge">type this</code>.  This declares a type with the
same name as the object we are declaring (which won’t be known until
we instantiate this module). For convenience, we create an alias <code class="language-plaintext highlighter-rouge">t</code>
for this type. This interface of our abstact set type contains a
relation and two actions.</p>

<p>The relation <code class="language-plaintext highlighter-rouge">contains</code> acts as a <em>representation function</em>.  This
tells us what abstract set a given value of type <code class="language-plaintext highlighter-rouge">set</code> represents.
The representation function allows us write specifications using the
abstract value that is represented. This means we can can pass around
values of type <code class="language-plaintext highlighter-rouge">set</code> as if they were actually abstract sets instead of
arrays.</p>

<p>Now let’s specify the semantics of our two set operations in terms of
the <code class="language-plaintext highlighter-rouge">contains</code> relation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module set(elem) = {
    ...

    object spec = {
        after emptyset {
            assert ~contains(s,X)
        }
        after add {
            assert contains(s,X) &lt;-&gt; (contains(old s,X) | X = e)
        }
    }
</code></pre></div></div>

<p>The action <code class="language-plaintext highlighter-rouge">emptyset</code> returns a representation of the empty set, while
<code class="language-plaintext highlighter-rouge">add</code> returns set <code class="language-plaintext highlighter-rouge">s</code> with element <code class="language-plaintext highlighter-rouge">e</code> added. Notice that the set
parameter of <code class="language-plaintext highlighter-rouge">add</code> is both input and output. This indiciates to the
compiler that we wish to avoid copying if possible. In most cases,
this will allowed the compiled code of <code class="language-plaintext highlighter-rouge">add</code> to modify the set in
place.</p>

<p>Let’s have a hack at implementing these operations. The implementation
usually provides a concrete data representation, a definition for each
function or relation in the interface, and code for each
action. Typically it instantiates some modules to provide the concrete
representation. Here’s one way we could implement <code class="language-plaintext highlighter-rouge">set</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>include collections
include order

module set(index,elem) = {
    ...

    instance index : unbounded_sequence
    instance arr : array(index.t,elem)
    destructor repr(X:t) : arr
    
    definition contains(X:t,y:elem) = exists Z. 0 &lt;= Z &amp; Z &lt; repr(X).end &amp; repr(X).value(Z) = y
    
implement emptyset {
    repr(s) := arr.create(0,0)
}

implement add {
    if ~contains(s,e) {
            repr(s) := arr.resize(repr(s),index.next(arr.end(repr(s))),e)
    }
    }

isolate iso = this
}
</code></pre></div></div>

<p>This implementation uses an unbounded array as a representation.
The concrete type is usually provide by giving the abstract type a
<em>private destructor</em>, in this case the function <code class="language-plaintext highlighter-rouge">repr</code> from type <code class="language-plaintext highlighter-rouge">t</code> to
the array type. Giving the destructor in this way is equivalent to
writing:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type t = struct {
    repr : arr
}
</code></pre></div></div>

<p>except the that field <code class="language-plaintext highlighter-rouge">repr</code>, being a component of the implementation,
is not visible to users of <code class="language-plaintext highlighter-rouge">set</code> (it’s similar to a private member in
C++). We use the function <code class="language-plaintext highlighter-rouge">repr</code> to access the internal representation
of a set.</p>

<p>Next, we give the definition of <code class="language-plaintext highlighter-rouge">contains</code> in terms of <code class="language-plaintext highlighter-rouge">repr</code>. This
definition is also private. We say that <code class="language-plaintext highlighter-rouge">contains(x,y)</code> is <code class="language-plaintext highlighter-rouge">true</code>
if a given <code class="language-plaintext highlighter-rouge">elem</code> <em>y</em> can be found somewhere in the array representing
set <code class="language-plaintext highlighter-rouge">x</code>.</p>

<p>The implementation of <code class="language-plaintext highlighter-rouge">emptyset</code> returns an empty array. To add an
element to a set, we test whether the element is already present.  If
not, we resize the array to make it one value larger, where the added
value is <code class="language-plaintext highlighter-rouge">e</code>, the new element.</p>

<p>Finally, we create an isolate containing our object so it will be
verified separately.</p>

<p>Notice that in the implementation of <code class="language-plaintext highlighter-rouge">add</code>, we evaluate the predicate
<code class="language-plaintext highlighter-rouge">contains</code>.  IVy recognizes that <code class="language-plaintext highlighter-rouge">contains</code> is executable because the
quantifier in the definition of <code class="language-plaintext highlighter-rouge">contains</code> is bounded. This means it
can compile the quantifier into a loop from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">arr.end(X)</code>. If
you try to compile an unbounded quantifier into executable code, IVy
will complain.</p>

<p>Also notice that instead of <code class="language-plaintext highlighter-rouge">arr.end(s) + 1</code>, we wrote
<code class="language-plaintext highlighter-rouge">index.next(arr.end(s))</code>.  That is, we are treating <code class="language-plaintext highlighter-rouge">index</code> as an
abstract datatype, assuming only that it provides an order <code class="language-plaintext highlighter-rouge">&lt;</code> and an
action <code class="language-plaintext highlighter-rouge">next</code>. From a software engineering point of view, this is
probably useless abstraction. However, from a verification point of
view, it is useful – it allows us to verify <code class="language-plaintext highlighter-rouge">set</code> without using the
theory or arithmetic.</p>

<p>The implementation is moderately efficient. That is, if the caller
of <code class="language-plaintext highlighter-rouge">add</code> writes:</p>

<p>s := set.add(s,e)</p>

<p>the compiler will recognize that the array <code class="language-plaintext highlighter-rouge">s</code> can be modified in
place. On the other hand, evaluating <code class="language-plaintext highlighter-rouge">contains</code> will still be linear
time in the array size, since it loops over the array. This approach
is only practical for small sets.</p>

<p>To try out our sets, we instantiate a set type:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type elem
instance s : set(elem)
</code></pre></div></div>

<p>We export our two actions:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export s.emptyset
export s.add
</code></pre></div></div>

<p>Then we verify:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ivy_check arrayset.ivy
ivy_check arrayset.ivy 
Checking isolate s.impl.index.iso...
trying ext:s.impl.index.next...
checking consecution...
Checking isolate s.iso...
trying ext:s.add...
checking consecution...
trying ext:s.emptyset...
checking consecution...
OK
</code></pre></div></div>

<p>Notice that even though the object <code class="language-plaintext highlighter-rouge">index</code> was instantiated from the
standard library, IVy still verified it. Generally speaking, even
trusted modules have properties that need to be verified when
instantiated in a particular environment.</p>

<h1 id="representation-invariants">Representation invariants</h1>

<p>Now let’s try adding an action to our <code class="language-plaintext highlighter-rouge">set</code> module that removes an element:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> module set(index,elem) = {
     ...
     action remove(s:t,e:elem) returns (s:t)

     object spec = {
         ...
         after remove {
             assert contains(s,X) &lt;-&gt; (contains(old s,X) &amp; X ~= e);
         }
    }

    object impl = {
        ...
        implement remove {
            if some (i:index.t) 0 &lt;= i &amp; i &lt; repr(s).end &amp; repr(s).value(i) = e {
                var last := repr(s).end.prev;
                repr(s) := repr(s).set(i,repr(s).get(last));
                repr(s) := repr(s).resize(last,0)
            }
        }
    }
}
</code></pre></div></div>

<p>This implementation of <code class="language-plaintext highlighter-rouge">remove</code> scans the array for some index <code class="language-plaintext highlighter-rouge">i</code> whose value is <code class="language-plaintext highlighter-rouge">e</code>.
If such an <code class="language-plaintext highlighter-rouge">i</code> exists, the value <code class="language-plaintext highlighter-rouge">e</code> is removed by replacing it with the last value
in the array and then resizing the array to make it one element smaller.</p>

<p>Unfortunately, this implementation doesn’t work: if the input array
contains two copies of the element <code class="language-plaintext highlighter-rouge">e</code>, one copy will remain. One
solution to this problem is to use a <em>representation invariant</em>. This
is a predicate a predicate that must be true of a value for it to be a
valid representation. The representation invariant is assumed to be
true of input values and must hold of output values.</p>

<p>In the case of our sets, the representation invariant is that no value
occurs twice in the array. It is part of the interface, and like <code class="language-plaintext highlighter-rouge">contains</code>, its definition
is private:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    relation valid(X:t)
</code></pre></div></div>

<p>We have to specify our interface to make the appropriate assumptions and guarantees:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object spec = {
    after emptyset {
        assert ~contains(s,X)
    }
    before add {
        assert valid(s)
    }
    after add {
        assert contains(s,X) &lt;-&gt; (contains(old s,X) | X = e);
        assert valid(s)
    }
    before remove {
        assert valid(s)
    }
    after remove {
        assert contains(s,X) &lt;-&gt; (contains(old s,X) &amp; X ~= e);
        assert valid(s)
    }
}
</code></pre></div></div>

<p>We give the definition of <code class="language-plaintext highlighter-rouge">valid</code> in the implementation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object impl = {
    ...
    definition valid(X:t) =
        forall Y,Z. (0 &lt;= Y &amp; Y &lt; repr(X).end &amp; 0 &lt;= Z &amp; Z &lt; repr(X).end
                      &amp; repr(X).value(Y) = repr(X).value(Z) -&gt; Y = Z)
}
</code></pre></div></div>

<p>Now we can verify that our implementation of <code class="language-plaintext highlighter-rouge">remove</code> works (try
verifying <a href="https://kenmcmil.github.io/examples/arrayset2.ivy">arrayset2.ivy</a>). There is a disadvantage to
this approach, however. Users of our <code class="language-plaintext highlighter-rouge">set</code> module now have to keep
track of the invariant that set values are valid. This could lead to many
“boilerplate” invariant conjectures. One day, IVy will solve this problem
using predicate subtypes.</p>

<h1 id="array-and-loops">Array and loops</h1>

<p>For now, it might be best to just implement <code class="language-plaintext highlighter-rouge">remove</code> in a way that doesn’t
rely on a representation invariant. We can do this using a <code class="language-plaintext highlighter-rouge">while</code> loop.
Here is the implementation we have in mind:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>action remove(s:t,e:elem) returns (res:t)

object impl = {
    ...

    implement remove {
        local i:index.t, end:index.t {
            i := 0;
            res := emptyset;
            end := arr.end(s);
            while i &lt; end
            {
                local f:elem {
                    f := arr.get(s,i);
                    if  f ~= e {
                        res := add(res,f)
                    }
                };
                i := index.next(i)
            }
        }
    }
}
</code></pre></div></div>

<p>That is, we scan the input array <code class="language-plaintext highlighter-rouge">s</code>. When we encounter a value not
equal to the output set <code class="language-plaintext highlighter-rouge">res</code>. This is easy enough to write, but Ivy
can’t prove it correct because of the loop. We’re going to need an
inductive invariant.</p>

<p>Before diving in to the proof, let’s consider the general schema of
inductive proofs of loops. We think of the loop as computing an
approximation to a desired function that approaches the correct result
with each iteration. We’ll call this function <code class="language-plaintext highlighter-rouge">step(i)</code>, where <code class="language-plaintext highlighter-rouge">i</code> is
the loop index. Suppose we want our loop to compute the “or” of the
bits in an array <code class="language-plaintext highlighter-rouge">a</code>, that is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> function or = exists X. 0 &lt;= X &amp; X &lt; arr.end(a) &amp; arr.value(a,X)
</code></pre></div></div>

<p>Then our step function would be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> function step(i) = exists X. 0 &lt;= X &amp; X &lt; i &amp; arr.value(a,X)
</code></pre></div></div>

<p>That is, our approximation is the “or” of all the bits up to (but not
including) the index <code class="language-plaintext highlighter-rouge">i</code>.</p>

<p>Now we need to give an <em>inductive</em> characterization of <code class="language-plaintext highlighter-rouge">step</code>. That
is, we need to know how to compute the value of <code class="language-plaintext highlighter-rouge">step</code> at the next
iteration. It looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>property 0 &lt;= I &amp; index.succ(I,J) -&gt; step(J) = (step(I) | arr.value(a,I))
</code></pre></div></div>

<p>That is, to compute approximation for the successor of index <code class="language-plaintext highlighter-rouge">I</code>, we
“or” <code class="language-plaintext highlighter-rouge">step(I)</code> with the bit in the array at index <code class="language-plaintext highlighter-rouge">I</code>. Ivy can prove
this property from the definition of <code class="language-plaintext highlighter-rouge">step</code>. It just unfolds the definition
of <code class="language-plaintext highlighter-rouge">step</code> for <code class="language-plaintext highlighter-rouge">I</code> and <code class="language-plaintext highlighter-rouge">J</code> and uses its EPR decision procedure.
Notice we use the successor relation <code class="language-plaintext highlighter-rouge">succ</code> provided by the index type
to represent the fact that <code class="language-plaintext highlighter-rouge">J</code> is next after <code class="language-plaintext highlighter-rouge">I</code>. This is because we
can’t call the action <code class="language-plaintext highlighter-rouge">next</code> in a property of function definition.</p>

<p>Now we need to know that when we get to the and of the array, we have
the desired result. Here is how we write this condition:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>property I = arr.end(a) -&gt; step(I) = or
</code></pre></div></div>

<p>Again, Ivy can easily prove this from the definitions of <code class="language-plaintext highlighter-rouge">step</code> and
<code class="language-plaintext highlighter-rouge">or</code>. If you squint at these two properties a bit, you’ll see that
they are very close to a logic program for computing <code class="language-plaintext highlighter-rouge">or</code> (in fact,
we could easily recast them in the form of <a href="https://en.wikipedia.org/wiki/Horn_clause">Horn
clauses</a>). A logic
programming system could execute them directly to compute our result.
We have have in mind, however, to do the computation using a loop:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i := 0;
res := false;
while i &lt; arr.end(a)
    invariant 0 &lt;= i &amp; i &lt;= arr.end(a)
    invariant res = step(i)
{
    res := res | arr.value(a,i);
    i := index.next(i)
} 
assert res = or
</code></pre></div></div>

<p>Notice the two invariants decorating the loop. IVy can prove that that
they are inductive and that the assertion is true. This can be done
using only our two properties, without reference to the actual
definition definition of <code class="language-plaintext highlighter-rouge">step</code>. This is the general approach for
writing a loop in IVy: first characterize the loop inductively, then
write the loop with two invariants as above.</p>

<p>Now let’s get back to the <code class="language-plaintext highlighter-rouge">remove</code> method. We start with the step
function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function remove_step (s:t,e:elem,i:index.t,y:elem)
        = (exists Z. 0 &lt;= Z &amp; Z &lt; i &amp; arr.value(s,Z) = y) &amp; y ~= e
</code></pre></div></div>

<p>This is an approximation of the representation function
<code class="language-plaintext highlighter-rouge">contains</code>. Here, <code class="language-plaintext highlighter-rouge">s</code> is the input set, <code class="language-plaintext highlighter-rouge">e</code> is the element to remove,
<code class="language-plaintext highlighter-rouge">i</code> is the loop index and <code class="language-plaintext highlighter-rouge">y</code> is an element to test for
membership. The function yields true if <code class="language-plaintext highlighter-rouge">y</code> is not the removed element
<code class="language-plaintext highlighter-rouge">e</code> and if it occurs before index <code class="language-plaintext highlighter-rouge">i</code> in the input set. In other
words, this function gives us the output set accumulated up to index
<code class="language-plaintext highlighter-rouge">i</code>.</p>

<p>Now we need an inductive charaterization. Basically, we add an element
of the array to the output set if it is not the removed element:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>property I &gt;= 0 &amp; index.succ(I,J) -&gt;
    (remove_step(X,E,J,Y) &lt;-&gt; (remove_step(X,E,I,Y) | arr.value(X,I) = Y &amp; Y ~= E))
</code></pre></div></div>

<p>The exit condition tells us when we have completed the computation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>property I = arr.end(X) -&gt;
    (remove_step(X,E,I,Y) &lt;-&gt; (contains(X,Y) &amp; Y~=E))
</code></pre></div></div>

<p>That is, when we reach the end of the array, we have accumulated all
the elements of the input set except <code class="language-plaintext highlighter-rouge">e</code>.</p>

<p>Now here’s the <code class="language-plaintext highlighter-rouge">remove</code> action, decorated with invariants:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>implement remove {
    local i:index.t, end:index.t {
        i := 0;
        res := arr.create(0,0);
        end := arr.end(s);
        while i &lt; end
            invariant 0 &lt;= i &amp; i &lt;= end
            invariant contains(res,Y) = remove_step(s,e,i,Y)
        {
            local f:elem {
                f := arr.get(s,i);
                if  f ~= e {
                    res := add(res,f)
                }
            };
            i := index.next(i)
        }
    }
}
</code></pre></div></div>

<p>Notice that the invariant is universally quantified on <code class="language-plaintext highlighter-rouge">Y</code>, the test
element. The invariant says that our loop computes exactly what our
inductive characterization computes. Ivy can easily verify that <a href="arrayset3.ivy">this
version</a> of <code class="language-plaintext highlighter-rouge">remove</code> satisfies its specification.</p>

<p>Of course, this might seem like a lot of work for around ten lines of
code. This style of proof has a big advantage, though, from the point
of view of automating the proof. That is, the places in the Horn
clauses where definitions need to be unfolded are clear. We don’t need
fragile quantifier instantiation heuristics to make the proof go
through.</p>

<p>In general, though, it’s best to avoid this kind of painstaking
construction of loops by using higher-level operations on containers.</p>


	</div>
	
      </article>

    </div>

    <div class="unit one-fourth hide-on-mobiles">
  <aside>
    
    <h4>Documentation</h4>
    <ul>

  
  
  <li class=""><a href="../install.html">Installing IVy</a></li>

  
  
  <li class=""><a href="../language.html">The Ivy language</a></li>

  
  
  <li class=""><a href="../commands.html">IVy command reference</a></li>

  
  
  <li class=""><a href="../decidability.html">Decidability</a></li>

  
  
  <li class=""><a href="../proving.html">IVy as a theorem prover</a></li>

</ul>

    
    <h4>IVy by example</h4>
    <ul>

  
  
  <li class=""><a href="client_server_example.html">Invariants</a></li>

  
  
  <li class=""><a href="specification.html">Specifications</a></li>

  
  
  <li class=""><a href="datatypes.html">Abstract Datatypes</a></li>

  
  
  <li class=""><a href="leader.html">Parameterized systems</a></li>

  
  
  <li class=""><a href="helloworld.html">Hello, world!</a></li>

  
  
  <li class=""><a href="networking.html">Networking</a></li>

  
  
  <li class="current"><a href="values.html">Concrete data</a></li>

  
  
  <li class=""><a href="list_reverse.html">Deduction example: array reversal</a></li>

  
  
  <li class=""><a href="indexset.html">Deduction example: majority</a></li>

  
  
  <li class=""><a href="window.html">Example: sliding window</a></li>

  
  
  <li class=""><a href="number_theory.html">Number theory</a></li>

</ul>

    
    <h4>Sharded Hash Table</h4>
    <ul>

  
  
  <li class=""><a href="sht/sharded_hash_table.html">Introduction</a></li>

  
  
  <li class=""><a href="sht/key.html">Keys</a></li>

  
  
  <li class=""><a href="sht/shard.html">Shards</a></li>

  
  
  <li class=""><a href="sht/table.html">Tables</a></li>

  
  
  <li class=""><a href="sht/delmap.html">Delegation Map</a></li>

  
  
  <li class=""><a href="sht/seqnum.html">Sequence Numbers</a></li>

  
  
  <li class=""><a href="sht/queue.html">Message Queues</a></li>

  
  
  <li class=""><a href="sht/trans.html">Transport Service</a></li>

  
  
  <li class=""><a href="sht/reference.html">Reference object</a></li>

  
  
  <li class=""><a href="sht/proto.html">Protocol</a></li>

  
  
  <li class=""><a href="sht/sht.html">Final Assembly</a></li>

</ul>

    
    <h4>Compositional Testing</h4>
    <ul>

  
  
  <li class=""><a href="testing/intro.html">Introduction</a></li>

  
  
  <li class=""><a href="testing/specification.html">Specifications</a></li>

  
  
  <li class=""><a href="testing/leader.html">Layered protocols</a></li>

</ul>

    
  </aside>
</div>


    <div class="clear"></div>

  </div>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>IVy</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>
IVy is a research tool intended to allow interactive development of protocols and their proofs of correctness and to provide a platform for developing and experimenting with automated proof techniques. In particular, IVy provides interactive visualization of automated proofs, and supports a use model in which the human protocol designer and the automated tool interact to expose errors and prove correctness.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
